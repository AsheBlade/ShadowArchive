---
layout: post
title: 问1730题
date: 2021-06-15
author: Shadow Walker
tags: [Algorithm,BFS]
---

这道题不是不会, 是自己的算力过高, 在input过大的时候跑不出来, 但让我疑惑的是, 我感觉最高赞答案跟我的完全是一样的思路, 一样的算力, 最高答案却能跑出来. 我想让您帮我看看我写的究竟哪里出错了, 这道题就是简单的BFS而已, 大体思路我完全清晰. 

## 原题

[LC1730](https://leetcode.com/problems/shortest-path-to-get-food/)

## 自己写的

这是我自己写的, 跑过了所有的example cases, 但是input巨大的时候跑不出来. 思路很简单, 就是非常基本的BFS.  下面这个code您可以直接复制粘贴到题目之中就能跑. 

```java
class Solution {
    public int getFood(char[][] grid) {
        Queue<int[]> q = new LinkedList<>();
        q.offer(findStart(grid));
        
        int ROW = grid.length;
        int COL = grid[0].length;
        
        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};
        boolean[][] visited = new boolean[ROW][COL];
        
        int steps = 0;
        while(!q.isEmpty()){
            steps++;
            int n = q.size();
            for(int i=0; i<n; i++){
                int[] p = q.poll();
                int row = p[0];
                int col = p[1];
                visited[row][col] = true;
                
                for(int[] direction: directions){
                    int newRow = row + direction[0];
                    int newCol = col + direction[1];
                    if(checkBoundary(newRow, newCol, ROW, COL, grid)){
                        if(grid[newRow][newCol] == '#')
                            return steps;
                        else{
                            if(!visited[newRow][newCol]){
                                q.offer(new int[]{newRow,newCol});
                            }
                        }
                    }
                }
            }
        }
        return -1;
    }
    
    private boolean checkBoundary(int row, int col, int ROW, int COL, char[][]grid){
        return row>=0 && row<ROW && col>=0 && col<COL && grid[row][col]!='X';
    }
    
    private int[] findStart(char[][] grid){
        for(int i=0; i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j]=='*'){
                    return new int[]{i,j};
                }
            }
        }
        return new int[]{-1,-1};
    }
}
```

## 最高赞答案

最高赞答案[在此](https://leetcode.com/problems/shortest-path-to-get-food/discuss/1127459/JAVA-BFS-Clean-Solution), code也放在了下面. 我觉得他这个跟我写的完全是一模一样, 我想了半天想不出来任何区别. 

而这个最高赞我跑了之后竟然超过50%算力, 而我自己的根本跑不出来. **我想了很久, 想不出来我自己上面到底哪里错了, 我想请您帮我看看**. 

```java
int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};

public int getFood(char[][] grid) {

	int m = grid.length;
	int n = grid[0].length;

	Queue<int[]> q = new LinkedList<>();
	q.add(findStart(grid));

	boolean[][] visited = new boolean[m][n];

	int step=0;
	while(!q.isEmpty()){
		int len = q.size();
		for(int i=0; i < len; i++){
			int[] pos = q.poll();

			int x = pos[0];
			int y = pos[1];

			if(grid[x][y] == '#') return step;

			for(int[] dir: dirs){
				int newX = x + dir[0];
				int newY = y + dir[1];

				if(isValid(grid, newX, newY) && !visited[newX][newY]){
					visited[newX][newY] = true;
					q.offer(new int[]{newX, newY});
				}
			}
		}
		step++;
	}

	return -1;
}

private int[] findStart(char[][] grid){
	for(int i=0; i < grid.length; i++){
		for(int j=0; j < grid[0].length; j++){
			if(grid[i][j] == '*'){
				return new int[]{i, j};
			}
		}
	}
	throw new RuntimeException();
}

private boolean isValid(char[][] grid, int i, int j){
	return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] != 'X';
}
```

