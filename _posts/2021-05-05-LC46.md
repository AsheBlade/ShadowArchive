---
layout: post
title: LC46_Permutations
date: 2021-05-05
author: Shadow Walker
tags: [OPLC, Algorithm, BackTrack]
toc: true
comments: true
---


## 原题
LC46
## 推荐度
4星
## 历程

2021-05-03 jinhui amazon mock之中失败. 
## 难点

LC17题是排列, 这道题是组合, 两道题适合一起看, 这道题比17题更难. 解法极为类似.  其实不是非常复杂的backTrack, 只是递归不容易想. 

- output 加入 arraylist的时候必须克隆新建, 不然之后会被污染. arraylist不是primitive. 
- swap的这个想法是需要动点脑子的, 其实最简单的方法是动笔. 
- 这道题还是常规的三行backtrack. 想不明白backTrack的最后一行其实可以先去看17题, 更简单一些. 
- 递归还是需要多想. 这道就是, 多想, 走路也多想, 想多了自然云开雾散. 
- 实在不行就直接背下来, 这道题可以背. 

## 答案

自己照官方答案修改的答案. 官方答案有点问题, 有点啰嗦. 自己改了一下, 真的比官方要好. 

官方的动画挺好的, 解释说明也不错, 但code不行, code看我的, 解释说明看官方. 

```java
class Solution {
    private List<List<Integer>> output; 
  public void backTrack(int first, List<Integer> nums) {
    // if all integers are used up
    if (first == nums.size() -1){
         //!!! 此处需要克隆一个新的nums, 如果直接add(nums), 会造成reference, 
        //nums不是primitive type之后会被更改. 如果直接用nums会导致所有都会指向同一个nums.
        output.add(new ArrayList<Integer>(nums));  

        return;
    }
      
    for (int i = first; i < arrayLength; i++) {
      // place i-th integer first 
      // in the current permutation
      Collections.swap(nums, first, i);
      // use next integers to complete the permutations
      backTrack(first + 1, nums);
      // backtrack
      Collections.swap(nums, first, i);
    }
  }

  public List<List<Integer>> permute(int[] nums) {
    // init output list
    output = new ArrayList<>();

    // convert nums into list since the output is a list of lists
    List<Integer> nums_lst = new ArrayList<>();
    for (int num : nums)
      nums_lst.add(num);

    backTrack(0, nums_lst);
    return output;
  }
}
```

## Complexity Analysis

看官方答案分析