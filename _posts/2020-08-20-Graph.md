---
layout: post
title: Graph
date: 2020-08-20
author: Shadow Walker
tags: [Algorithm, Interview]
toc: true
---

## Overview

我目前认为图论这一部分表面上虽然很难, 但其实结构和算法就只有那么几种. 其实只要把一道题的脉络梳理清楚, 建立合适的模型, 所有的东西也就迎刃而解.  对这一部分要理清概念和结构为主, 刷题为次.  

Graph可以理解为高级的tree, 熟练掌握tree的相关知识会对这一部分有很大帮助. 

## Constructor

构建Graph只有两种途径:

1. Adjacency Matrix
2. Adjacency List

这里使用Adjacency List, 如图:

![](../uploads/graph1.jpg)

转化成Adjacency List:

![](../uploads/graph5.jpg)

以下和 DFS/BFS 代码来自 [Baeldung](https://www.baeldung.com/java-graphs)

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Graph {
    private Map<Vertex, List<Vertex>> adjVertices;

    Graph() {
        this.adjVertices = new HashMap<Vertex, List<Vertex>>();
    }

    void addVertex(String label) {
        adjVertices.putIfAbsent(new Vertex(label), new ArrayList<>());
    }

    void removeVertex(String label) {
        Vertex v = new Vertex(label);
        adjVertices.values().stream().forEach(e -> e.remove(v));
        adjVertices.remove(new Vertex(label));
    }

    void addEdge(String label1, String label2) {
        Vertex v1 = new Vertex(label1);
        Vertex v2 = new Vertex(label2);
        adjVertices.get(v1).add(v2);
        adjVertices.get(v2).add(v1);
    }

    void removeEdge(String label1, String label2) {
        Vertex v1 = new Vertex(label1);
        Vertex v2 = new Vertex(label2);
        List<Vertex> eV1 = adjVertices.get(v1);
        List<Vertex> eV2 = adjVertices.get(v2);
        if (eV1 != null)
            eV1.remove(v2);
        if (eV2 != null)
            eV2.remove(v1);
    }

    List<Vertex> getAdjVertices(String label) {
        return adjVertices.get(new Vertex(label));
    }
    
    String printGraph() {
        StringBuffer sb = new StringBuffer();
        for(Vertex v : adjVertices.keySet()) {
            sb.append(v);
            sb.append(adjVertices.get(v));
        }
        return sb.toString();
    }

    class Vertex {
        String label;
        Vertex(String label) {
            this.label = label;
        }
        
        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + getOuterType().hashCode();
            result = prime * result + ((label == null) ? 0 : label.hashCode());
            return result;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Vertex other = (Vertex) obj;
            if (!getOuterType().equals(other.getOuterType()))
                return false;
            if (label == null) {
                if (other.label != null)
                    return false;
            } else if (!label.equals(other.label))
                return false;
            return true;
        }

        @Override
        public String toString() {
            return label;
        }


        private Graph getOuterType() {
            return Graph.this;
        }
    }
}
```

## Traversal

```java
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

import com.baeldung.graph.Graph.Vertex;

public class GraphTraversal {
    static Set<String> depthFirstTraversal(Graph graph, String root) {
        Set<String> visited = new LinkedHashSet<String>();
        Stack<String> stack = new Stack<String>();
        stack.push(root);
        while (!stack.isEmpty()) {
            String vertex = stack.pop();
            if (!visited.contains(vertex)) {
                visited.add(vertex);
                for (Vertex v : graph.getAdjVertices(vertex)) {              
                    stack.push(v.label);
                }
            }
        }
        return visited;
    }

    static Set<String> breadthFirstTraversal(Graph graph, String root) {
        Set<String> visited = new LinkedHashSet<String>();
        Queue<String> queue = new LinkedList<String>();
        queue.add(root);
        visited.add(root);
        while (!queue.isEmpty()) {
            String vertex = queue.poll();
            for (Vertex v : graph.getAdjVertices(vertex)) {
                if (!visited.contains(v.label)) {
                    visited.add(v.label);
                    queue.add(v.label);
                }
            }
        }
        return visited;
    }
}
```

## DFS

概念并不难理解, 就是往深了走, 深到没有路之后, 再backtrack. 如果一时理解不了可以先看一下tree 的DFS. 

**Algorithm:**  

1. Create a recursive function that takes the index of node and a visited array.  
2. Mark the current node as visited and print the node.  
3. Traverse all the adjacent and unmarked nodes and call the recursive function with index of adjacent node.  

**Implementation:**

```java
// Java program to print DFS traversal from a given given graph 
import java.io.*; 
import java.util.*; 

// This class represents a directed graph using adjacency list 
// representation 
class Graph 
{ 
	private int V; // No. of vertices 

	// Array of lists for Adjacency List Representation 
	private LinkedList<Integer> adj[]; 

	// Constructor 
	Graph(int v) 
	{ 
		V = v; 
		adj = new LinkedList[v]; 
		for (int i=0; i<v; ++i) 
			adj[i] = new LinkedList(); 
	} 

	//Function to add an edge into the graph 
	void addEdge(int v, int w) 
	{ 
		adj[v].add(w); // Add w to v's list. 
	} 

	// A function used by DFS 
	void DFSUtil(int v,boolean visited[]) 
	{ 
		// Mark the current node as visited and print it 
		visited[v] = true; 
		System.out.print(v+" "); 

		// Recur for all the vertices adjacent to this vertex 
		Iterator<Integer> i = adj[v].listIterator(); 
		while (i.hasNext()) 
		{ 
			int n = i.next(); 
			if (!visited[n]) 
				DFSUtil(n, visited); 
		} 
	} 

	// The function to do DFS traversal. It uses recursive DFSUtil() 
	void DFS(int v) 
	{ 
		// Mark all the vertices as not visited(set as 
		// false by default in java) 
		boolean visited[] = new boolean[V]; 

		// Call the recursive helper function to print DFS traversal 
		DFSUtil(v, visited); 
	} 

	public static void main(String args[]) 
	{ 
		Graph g = new Graph(4); 

		g.addEdge(0, 1); 
		g.addEdge(0, 2); 
		g.addEdge(1, 2); 
		g.addEdge(2, 0); 
		g.addEdge(2, 3); 
		g.addEdge(3, 3); 

		System.out.println("Following is Depth First Traversal "+ 
						"(starting from vertex 2)"); 

		g.DFS(2); 
	} 
} 
// This code is contributed by Aakash Hasija 
```


## Hiertual 

```java
/*
 * Click `Run` to execute the snippet below!
 */

import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */

class Solution {
  public static void main(String[] args) {
    
    
    for (String string : strings) {
      System.out.println(string);
    }
  }
  

  
  
  private int ShortestPath(Graph g, String root, String Des)
      {
        
        // BFS search. 
        LinkedList<String> queue = new LinkedList<String>();
        
        // Add root to queue. 
        queue.add(root);
        int distance = 0;
    
        while(!queue.isEmpty()){
          
          String vertex = queue.poll();
        
          for(Vertex v: graph.getAdjVertices(vertex))
          {
            if(v.label == Des){
              distance ++;
              break;
            }
            else if(!visited.contains(v.label)){
              queue.add(v.label);
              distance ++;
            }
          }
        }
          
        return answer;
      }
      
      /* numV = number of vertex  numE
      O(numV + numE)
      
}



public class Graph{
  private Map<Vertex, List<Vertex>> adjVertices;
  
  Graph()
  {
    this.adjVertices = new HashMap<Vertex, List<Vertex>>();
  }
  
  private void addVertex(String s)
  {
    adjVertices.put(new Vertex(s), new ArrayList<>());
  }
  
 

  
}
  
  

    /*
init set to contain vertex
init a int called distance. 

starting from userid1, first put userid1 into set. 
find all vertex that 
/* 

Set{A, B, C}
A
dist: 1



Your previous Plain Text content is preserved below:

Users have connection between each other, we need to know what is the connection level when given two users.

given data like this:
    user_ids = ['A', 'B', 'C', 'D', 'E', 'F']
    connections = [('A', 'B'),
           ('A', 'C'),
           ('B', 'C'),
           ('C', 'E'),
           ('E', 'F'),
           ('D', 'F')]
  - write function:

  def get_connection_level(user_id1, user_id2):
    """
    input are two users
    return connection level, like 1st connection or 2nd or no connection

    input A, B
    return 1
    input A, E
    return 2
    input A, G
    return 0 no conneciton
    """
 */
 ```