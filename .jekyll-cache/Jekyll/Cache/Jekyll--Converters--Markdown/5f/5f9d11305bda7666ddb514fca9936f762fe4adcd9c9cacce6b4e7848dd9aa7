I"â„<h2 id="overview">Overview</h2>

<p>Sorting è¿™ä¸€å—å°±å¾ˆæç¬‘. å­¦äº†å¤šå°‘æ¬¡, è‡³å°‘å­¦äº†æœ‰3-4æ¬¡äº†. ç„¶ååå­—éƒ½çŸ¥é“, å°±æ˜¯è®°ä¸ä½, å­¦äº†å¿˜,å¿˜äº†å­¦. æœ€åå°±è®°ä½insertionå’Œselection. <br />
è¿™ä¸€æ¬¡å…¨éƒ¨æ€»ç»“ä¸€ä¸‹, ä»¥åä¹Ÿå°±ä¸ç”¨æŸ¥äº†, ç›´æ¥åˆ°è¿™é‡Œçœ‹.</p>

<p>Bubble sort æ˜¯çº¯brutal force, selection sortç¨å¾®èªæ˜ä¸€äº›, ä¹Ÿæ²¡å¥½åˆ°å“ªé‡Œå».  Insertion sortå®Œå…¨åœ¨ä»»ä½•æƒ…å†µéƒ½æ¯”selectionå¿«. æ‰€ä»¥å…¶å®è¿™ä¸‰ç§éƒ½å¯ä»¥ä¸æ€ä¹ˆçœ‹. <strong>é‡ç‚¹åœ¨äºMerge sort</strong>, æ—¢æ˜¯divde&amp;conquer, è¿˜è€ƒå¯Ÿrecursive, éœ€è¦é‡ç‚¹æŒæ¡.  Quickå€¼å¾—äº†è§£, ç”¨çš„ä¸å¤š.</p>

<h2 id="bubble-sort">Bubble Sort</h2>

<p>æœ€åŸºæœ¬çš„brutal force sorting, ä»»ä½•åœºåˆéƒ½ä¸ä¼šç”¨åˆ°.   å°±æ˜¯ä»å¤´åˆ°å°¾ä¸€éä¸€éçš„è¿‡næ¬¡, å¦‚æœå‰ä¸€ä¸ªæ¯”åä¸€ä¸ªå¤§å°±swap,ç›´åˆ°æ²¡æœ‰swapä¸ºæ­¢.</p>

<h3 id="code">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An optimized version of Bubble Sort </span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">temp</span><span class="o">;</span> 
    <span class="kt">boolean</span> <span class="n">swapped</span><span class="o">;</span> 
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>  
    <span class="o">{</span> 
    	<span class="c1">// æ­¤å¤„ç”¨n-1æ¬¡for loopå¯ä»¥ä¿è¯æœ€åä¸€å®šsorting, ä¹Ÿå¯ä»¥ç”¨while(!swap), æ•ˆæœæ˜¯ä¸€æ ·çš„</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>  
        <span class="o">{</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>  
            <span class="o">{</span> 
                <span class="c1">// swap arr[j] and arr[j+1] </span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> 
                <span class="n">swapped</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 
            <span class="o">}</span> 
        <span class="o">}</span> 
  
        <span class="c1">// IF no two elements were  </span>
        <span class="c1">// swapped by inner loop, then break </span>
        <span class="c1">// è¿™æ˜¯ä¸€ä¸ªoptimalçš„ç®—æ³•, ä¹Ÿå¯ä»¥ä¸ç”¨swappedè¿™ä¸ªé‡, ç›´æ¥èµ°næ¬¡, èƒ½ä¿è¯æœ€åä¸€å®šæ˜¯sorted. </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">swapped</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> 
            <span class="k">break</span><span class="o">;</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>
<h3 id="space-and-time-complexity">Space and Time Complexity</h3>

<ul>
  <li>
    <p>Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.</p>
  </li>
  <li>
    <p>Best Case Time Complexity: O(n). Best case occurs when array is already sorted.</p>
  </li>
</ul>

<h2 id="selection-sort">Selection Sort</h2>

<p>å°±æ˜¯brutal,  ä¸¤ä¸ªfor loop, ä»å¤´åˆ°å°¾åˆ·ä¸€é, æ‰¾æœ€å°, å¡åˆ°ç¬¬ä¸€ä¸ª, ç„¶åå†æ‰¾æœ€å°, å¡åˆ°ç¬¬äºŒä¸ª, ä»¥æ­¤ç±»æ¨.</p>

<h3 id="code-1">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">min_idx</span><span class="o">;</span> 
  
    <span class="c1">// One by one move boundary of unsorted subarray </span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> 
    <span class="o">{</span> 
        <span class="c1">// Find the minimum element in unsorted array </span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> 
          <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">min_idx</span><span class="o">])</span> 
            <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> 
  
        <span class="c1">// Swap the found minimum element with the first </span>
        <span class="c1">// element </span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">min_idx</span><span class="o">];</span> 
        <span class="n">arr</span><span class="o">[</span><span class="n">min_idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>

<h3 id="space-and-time-complexity-1">Space and Time Complexity</h3>

<p>O(n^2)</p>

<h2 id="insertion-sort">Insertion Sort</h2>

<p>ä¹Ÿå¾ˆbrutal, æ•´ä¸ªarrayä»å¤´åˆ°å°¾åˆ·ä¸€é, å¦‚æœåä¸€ä¸ªæ¯”å‰ä¸€ä¸ªå°, å°±ç”¨while loopè·Ÿä¸Šä¸€ä¸ªæ¯”è¾ƒå¾€å‰æŒª, ç›´åˆ°æŒªåˆ°é€‚å½“çš„ä½ç½®ä¸ºæ­¢.</p>

<h3 id="algorithm">Algorithm</h3>

<p>To sort an array of size n in ascending order:</p>

<ol>
  <li>Iterate from arr[1] to arr[n] over the array.</li>
  <li>Compare the current element (key) to its predecessor.</li>
  <li>If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.</li>
</ol>

<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png" alt="" /></p>

<h3 id="code-2">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[])</span> 
    <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span> 
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> 
  
            <span class="cm">/* Move elements of arr[0..i-1], that are 
               greater than key, to one position ahead 
               of their current position */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> 
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> 
            <span class="o">}</span> 
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
</code></pre></div></div>

<h3 id="space-and-time-complexity-2">Space and Time Complexity</h3>

<p>O(n^2)</p>

<h2 id="merge-sort-éœ€è¦æŒæ¡--æœ€å¿«">Merge Sort (éœ€è¦æŒæ¡ | æœ€å¿«)</h2>

<ul>
  <li>Merge Sort is a Divide and Conquer algorithm.</li>
  <li>ç®€å•æ¥è¯´å°±æ˜¯ç”¨äºŒåˆ†æ³•æŠŠè¿™ä¸ªarrayä¸æ–­äºŒåˆ†, æœ€ååˆ†æˆä¸€ä¸ªæ•°çš„æ—¶å€™å†äº’ç›¸æ¯”è¾ƒé‡æ–°æ‹¼å›å».</li>
  <li><strong>Merge sort æ˜¯é€’å½’. å€¼å¾—åˆ·!</strong></li>
  <li><a href="https://www.studytonight.com/data-structures/merge-sort#:~:text=Time%20complexity%20of%20Merge%20Sort,space%20as%20the%20unsorted%20array.">Best Merge Sort guid I found on Internet</a></li>
</ul>

<h3 id="algorithm-1">Algorithm</h3>

<p>MergeSort(arr[], l,  r)<br />
If r &gt; l</p>

<ol>
  <li>Find the middle point to divide the array into two halves:<br />
     middle m = (l+r)/2</li>
  <li>Call mergeSort for first half: <br />
     Call mergeSort(arr, l, m)</li>
  <li>Call mergeSort for second half:
     Call mergeSort(arr, m+1, r)</li>
  <li>Merge the two halves sorted in step 2 and 3:
     Call merge(arr, l, m, r)</li>
</ol>

<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png" alt="" /></p>

<h3 id="code-3">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CS627_AS02</span> <span class="o">{</span>
    <span class="c1">// Main function that sorts arr[l..r] using</span>
<span class="c1">// merge()</span>
    <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Find the middle point</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Sort first and second halves</span>
            <span class="c1">// æ³¨æ„!! çœ‹è¿™ä¸ªrecursive, è¿™é‡Œæ˜¯ç”¨çš„è¿‘ä¼¼äºDFSçš„æœç´¢, æœåˆ°ç¬¬ä¸€ä¸ª, ç„¶åå†merge.</span>
            <span class="c1">//  ä¸€ä¸ªå¯¹mergeçš„é”™è¯¯å°è±¡æ˜¯å…ˆdivideåcombine, è€Œå…¶å®æ˜¯divide, combineåŒæ—¶è¿›è¡Œ.</span>
            <span class="c1">// è„‘å­é‡Œå¯ä»¥å†ä»”ç»†æƒ³æƒ³è¿™ä¸ªrecursion, ä¹Ÿå¯ä»¥å›å»çœ‹ä¸€ä¸‹DFS. é€’å½’éœ€è¦æ€è€ƒ.</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>

            <span class="c1">// Merge the sorted halves</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Merges two subarrays of arr[].</span>
<span class="c1">// First subarray is arr[l..m]</span>
<span class="c1">// Second subarray is arr[m+1..r]</span>
    <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// Find sizes of two subarrays to be merged</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">m</span><span class="o">;</span>

        <span class="cm">/* Create temp arrays */</span>
        <span class="kt">int</span> <span class="no">L</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="no">R</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n2</span><span class="o">];</span>

        <span class="cm">/*Copy data to temp arrays*/</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span>
            <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">j</span><span class="o">];</span>

        <span class="cm">/* Merge the temp arrays */</span>

        <span class="c1">// Initial indexes of first and second subarrays</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Initial index of merged subarry array</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>

    <span class="cm">/* æ³¨æ„!! å½“å¹´å­¦çš„æ—¶å€™æ¯”è¾ƒç–‘æƒ‘, ä¸¤ä¸ªarray combineçš„æ—¶å€™ä¸åº”è¯¥è¿˜æ˜¯O(n^2)å—?
    	å…¶å®ä¸ç„¶, ä¸¤ä¸ªunsorted arrayæ‰æ˜¯O(n^2).  ä¸¤ä¸ªsorted array combine ç”¨è¿™ä¸ªwhile loop O(n)å°±å¤Ÿäº†.
   	*/</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="cm">/* Copy remaining elements of L[] if any */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="cm">/* Copy remaining elements of R[] if any */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">j</span><span class="o">++;</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Driver method</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span> <span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Given Array"</span><span class="o">);</span>
        <span class="c1">//printArray(arr);</span>

        <span class="no">CS627_AS02</span> <span class="n">ob</span> <span class="o">=</span> <span class="k">new</span> <span class="no">CS627_AS02</span><span class="o">();</span>
        <span class="n">ob</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

        <span class="nc">String</span> <span class="n">arrayString</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="n">arrayString</span> <span class="o">=</span> <span class="n">arrayString</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">","</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arrayString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">arrayString</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="space-and-time-complexity-3">Space and Time Complexity</h3>

<p>As we have already learned in Binary Search that whenever we divide a number into half in every stpe, it can be represented using a logarithmic function, which is <code class="language-plaintext highlighter-rouge">log n </code>and the number of steps can be represented by <code class="language-plaintext highlighter-rouge">log n + 1</code> (at most)</p>

<p>Also, we perform a single step operation to find out the middle of any subarray, i.e. <code class="language-plaintext highlighter-rouge">O(1)</code>.</p>

<p>And to merge the subarrays, made by dividing the original array of <code class="language-plaintext highlighter-rouge">n</code> elements, a running time of <code class="language-plaintext highlighter-rouge">O(n)</code> will be required.</p>

<p>Hence the total time for <code class="language-plaintext highlighter-rouge">mergeSort</code> function will become <code class="language-plaintext highlighter-rouge">n(log n + 1)</code>, which gives us a time complexity of <code class="language-plaintext highlighter-rouge">O(n*log n)</code>.
<br /><br /><br /></p>

<ul>
  <li>
    <p>Worst Case Time Complexity [ Big-O ]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Best Case Time Complexity [Big-omega]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Average Time Complexity [Big-theta]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Space Complexity: <code class="language-plaintext highlighter-rouge">O(n)</code></p>
  </li>
</ul>

<h2 id="quick-sort">Quick Sort</h2>

<ul>
  <li>è·Ÿ merge sort ä¸€æ ·æ˜¯divide and conquer</li>
  <li>ç›¸è¾ƒäºmerge sortç›´æ¥äºŒåˆ†, quickæ˜¯é€‰ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒ, ç„¶åæŠŠèŠ‚ç‚¹æ”¾åœ¨å¯¹çš„ä½ç½®, ä¿è¯èŠ‚ç‚¹å‰æ¯”å…¶å°, åé¢æ¯”èŠ‚ç‚¹éƒ½å¤§, ä¹‹åå†è¿›è¡ŒäºŒåˆ†.</li>
  <li>é€‰èŠ‚ç‚¹pivotçš„æ–¹æ³•å¯ä»¥è‡ªç”±å‘æŒ¥, æ²¡æœ‰å›ºå®šè§„å®š.</li>
  <li>ä¸merge sortçš„ä¸åŒåœ¨äºæ‹¼å›å»çš„è¿‡ç¨‹ä¹‹ä¸­æ— éœ€å†æ¯”è¾ƒ</li>
</ul>

<h3 id="algorithm-2">Algorithm</h3>

<p>è¿™ä¸ªå›¾ä¸­é‡Œé€‰ç”¨çš„äº‹æœ€åä¸€ä¸ªæ•°ä½œä¸ºèŠ‚ç‚¹.</p>

<p><img src="../uploads/3odpn7gl8myiqx7rto4f.png" alt="Quick Sort Illustration" /></p>

<h3 id="code-4">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* This function takes last element as pivot, 
   places the pivot element at its correct 
   position in sorted array, and places all 
   smaller (smaller than pivot) to left of 
   pivot and all greater elements to right 
   of pivot */</span>
<span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>  
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// index of smaller element </span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">high</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> 
    <span class="o">{</span> 
        <span class="c1">// If current element is smaller than the pivot </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="n">i</span><span class="o">++;</span> 
  
            <span class="c1">// swap arr[i] and arr[j] </span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> 
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
  
    <span class="c1">// swap arr[i+1] and arr[high] (or pivot) </span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span> 
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">];</span> 
    <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> 
  
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> 
<span class="o">}</span> 
  
  
<span class="cm">/* The main function that implements QuickSort() 
  arr[] --&gt; Array to be sorted, 
  low  --&gt; Starting index, 
  high  --&gt; Ending index */</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* pi is partitioning index, arr[pi] is  
          now at right place */</span>
        <span class="kt">int</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span> 
  
        <span class="c1">// Recursively sort elements before </span>
        <span class="c1">// partition and after partition </span>
        <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pi</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> 
        <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>

<h3 id="space-and-time-complexity-4">Space and Time Complexity</h3>

<p>For an array, in which partitioning leads to unbalanced subarrays, to an extent where on the left side there are no elements, with all the elements greater than the pivot, hence on the right side.</p>

<p>And if keep on getting unbalanced subarrays, then the running time is the worst case, which is <code class="language-plaintext highlighter-rouge">O(n^2)</code></p>

<p>Where as if partitioning leads to almost equal subarrays, then the running time is the best, with time complexity as <code class="language-plaintext highlighter-rouge">O(n*log n)</code>.</p>

<ul>
  <li>
    <p>Worst Case Time Complexity [ Big-O ]: <code class="language-plaintext highlighter-rouge">O(n2)</code></p>
  </li>
  <li>
    <p>Best Case Time Complexity [Big-omega]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Average Time Complexity [Big-theta]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Space Complexity: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
</ul>

:ET