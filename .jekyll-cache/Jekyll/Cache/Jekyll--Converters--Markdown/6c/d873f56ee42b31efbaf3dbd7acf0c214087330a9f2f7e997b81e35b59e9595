I"K+<h2 id="overview">Overview</h2>

<p>这一篇是关于sliding window这个奇淫技巧的. 现在其实对于Array的考察非常烦人. 这一块比较简单所以没什么可考的, 一旦考的话, 就是这种奇淫技巧. 其实这种技巧工作和学习之中用途基本没有, 而且适用的题型也很少.</p>

<p>之所以想记录一下这个技巧是觉得其还是有一定的适用性, 也许以后能够用到.</p>

<h2 id="longest-substring-without-repeating-characters-lc_03">Longest Substring Without Repeating Characters LC_03</h2>

<p>就是这道题其实当时baanyan第一天还跟老师怼上了. 因为我当时说我用hashmap能解而且算力上并不慢. 现在想想应该是我错了. 我今天想了半天也没想到hashmap怎么能做出和这个标准答案算力一样的解法. <strong>所以说, 做人做学问还是应该虚心一点, 尾巴收起来</strong>. 我当时之所以瞧不上老师的解法是因为我当时(其实现在也存在)打心底瞧不起这种只适用于一道或者几道题的奇淫技巧, 觉得这种东西花拳绣腿, 学的比较鸡肋.</p>

<p>老师当时称这个解法为”双指针”, LC称这个解法为Sliding Window, 我更喜欢称之为游标卡尺.</p>

<p><strong>Problem Description</strong></p>

<p>Given a string s, find the length of the longest substring without repeating characters.</p>

<p>Example 1:</p>

<blockquote>
  <p>Input: s = “abcabcbb”<br />
Output: 3<br />
Explanation: The answer is “abc”, with the length of 3.</p>
</blockquote>

<p>Example 2:</p>

<blockquote>
  <p>Input: s = “bbbbb”<br />
Output: 1<br />
Explanation: The answer is “b”, with the length of 1.</p>
</blockquote>

<p><strong>Code</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">hs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">answer</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">hs</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span>
            <span class="o">{</span>
                <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                <span class="n">j</span><span class="o">++;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hs</span><span class="o">.</span><span class="na">size</span><span class="o">()&gt;</span><span class="n">answer</span><span class="o">)</span>
                <span class="o">{</span>
                    <span class="n">answer</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">hs</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Algorithm</strong></p>

<p>直接看以上这个code会比较迷, 我当时看答案也是看了很久没看明白. 其实自己在纸上写了一下很容易想明白.</p>

<p>其实这个算法并不难, 也不玄乎, 反而比较实际, 容易理解.  把Set hs想象成一把游标卡尺, 卡尺的左端是i, 右端是j. 
假设我们有一个String  ABCDAE</p>

<p>从A点出发, i和j都在0, 也就是A, 只要下一个char没有重复, 游标卡尺的右端就不断往下一个char走. 如上面的例子, 游标卡尺走到ABCDA, j = 4的时候会停住.  这个时候从A点出发的不重复subString已经到了Max. 这个时候把尺子右端不动, 把卡尺左端往后挪一位. 我们得到 BCDA. 之后下一位还是不重复的E, 再挪右端j, 左端i不动. 得到BCDAE. 这个过程中keep tracking 卡尺的max长度. 最后得到答案5.</p>

<p>两点:</p>

<ol>
  <li>一开始会考虑要不要向前track, 其实想一下完全没有必要. 这个理解就是和DP是一样的, 因为之前的元素已经被卡尺求过了, 没有必要向前. 所有的subString都是向后track.</li>
  <li>
    <p>一开始是在想是不是要在每个字母上卡一下, 是不是一旦出现了重复元素之后, 就立刻要把尺子收紧把左端右端合在一起然后重新测量, 会把else写成这样:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">else</span><span class="o">{</span>
     <span class="n">hs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
     <span class="n">i</span><span class="o">++;</span>
     <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <p>举个例子: ABCBD 这个, 一开始尺子卡在ABC, 然后在B发现重复, 尺子收起来, 从B(i=1)开始重新卡. 我会这么想, 其实这么想也比较直观.</p>

    <p>其实实际上没有必要. <strong>关键在于这个尺子里面的元素是不可重复的</strong>, 也就是说尺子内部的元素是绝对干净的. 这个时候没有必要收尺子, 尺子左端已经在正确的位置, 只要继续挪动右端就可以了.</p>
  </li>
</ol>

<p>还有一些更快的解法, 游标卡尺加上hashmap的解法, 不想去学了. 这种奇淫技巧学的差不多就可以. 目前阶段没必要学最优解, 现在主要是大量刷.</p>

<h2 id="container-with-most-water-lc_011">Container With Most Water LC_011</h2>

<p><strong>Problem Description</strong></p>

<p>题目不放了, 因为需要看图才能看懂, 直接去<a href="https://leetcode.com/problems/container-with-most-water/">LeetCode</a>上面看吧.</p>

<p><strong>Algorithm</strong></p>

<p>这道题我拿来首先想到的就是dynamic programming, 但越想越觉得不符合dynamic的求和原则, 因为需要考虑之前的所有边.</p>

<p>算法是游标卡尺, 这一次的游标卡尺是从首尾两端开始卡, 慢慢往里面收. 由于题目的特殊性而使用木桶原理.</p>

<p><strong>这种特殊的题目没什么好说的, 唯有刷脸.</strong></p>

<p><br /></p>

<p><strong>Code</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxArea</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">&gt;</span><span class="n">left</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="n">maxArea</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxArea</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])*(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">));</span>
            <span class="c1">//System.out.println(left + " , " + right + " , " + maxArea);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">]&gt;</span><span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span>
            <span class="o">{</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">else</span>
            <span class="o">{</span>
                <span class="n">left</span> <span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxArea</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
:ET