<!DOCTYPE html>
<html>
  <head>
  <title>Sorting – Jericho – 「さて、どこへ行こうかしらね。ネットは広大だわ」</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Overview

Sorting 这一块就很搞笑. 学了多少次, 至少学了有3-4次了. 然后名字都知道, 就是记不住, 学了忘,忘了学. 最后就记住insertion和selection. 
这一次全部总结一下, 以后也就不用查了, 直接到这里看.

Bubble sort 是纯brutal force, selection sort稍微聪明一些, 也没好到哪里去.  Insertion sort完全在任何情况都比selection快. 所以其实这三种都可以不怎么看. 重点在于Merge sort, 既是divde&amp;conquer, 还考察recursive, 需要重点掌握.  Quick值得了解, 用的不多.

Bubble Sort

最基本的brutal force sorting, 任何场合都不会用到.   就是从头到尾一遍一遍的过n次, 如果前一个比后一个大就swap,直到没有swap为止.

Code

// An optimized version of Bubble Sort 
static void bubbleSort(int arr[], int n) 
{ 
    int i, j, temp; 
    boolean swapped; 
    for (i = 0; i &lt; n - 1; i++)  
    { 
    	// 此处用n-1次for loop可以保证最后一定sorting, 也可以用while(!swap), 效果是一样的
        swapped = false; 
        for (j = 0; j &lt; n - i - 1; j++)  
        { 
            if (arr[j] &gt; arr[j + 1])  
            { 
                // swap arr[j] and arr[j+1] 
                temp = arr[j]; 
                arr[j] = arr[j + 1]; 
                arr[j + 1] = temp; 
                swapped = true; 
            } 
        } 
  
        // IF no two elements were  
        // swapped by inner loop, then break 
        // 这是一个optimal的算法, 也可以不用swapped这个量, 直接走n次, 能保证最后一定是sorted. 
        if (swapped == false) 
            break; 
    } 
} 

Space and Time Complexity


  
    Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.
  
  
    Best Case Time Complexity: O(n). Best case occurs when array is already sorted.
  


Selection Sort

就是brutal,  两个for loop, 从头到尾刷一遍, 找最小, 塞到第一个, 然后再找最小, 塞到第二个, 以此类推.

Code

void selectionSort(int arr[], int n) 
{ 
    int i, j, min_idx; 
  
    // One by one move boundary of unsorted subarray 
    for (i = 0; i &lt; n-1; i++) 
    { 
        // Find the minimum element in unsorted array 
        min_idx = i; 
        for (j = i+1; j &lt; n; j++) 
          if (arr[j] &lt; arr[min_idx]) 
            min_idx = j; 
  
        // Swap the found minimum element with the first 
        // element 
        int temp = arr[min_idx]; 
        arr[min_idx] = arr[i]; 
        arr[i] = temp;
    } 
} 


Space and Time Complexity

O(n^2)

Insertion Sort

也很brutal, 整个array从头到尾刷一遍, 如果后一个比前一个小, 就用while loop跟上一个比较往前挪, 直到挪到适当的位置为止.

Algorithm

To sort an array of size n in ascending order:


  Iterate from arr[1] to arr[n] over the array.
  Compare the current element (key) to its predecessor.
  If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.




Code

    void sort(int arr[]) 
    { 
        int n = arr.length; 
        for (int i = 1; i &lt; n; ++i) { 
            int key = arr[i]; 
            int j = i - 1; 
  
            /* Move elements of arr[0..i-1], that are 
               greater than key, to one position ahead 
               of their current position */
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { 
                arr[j + 1] = arr[j]; 
                j = j - 1; 
            } 
            arr[j + 1] = key; 
        } 
    } 


Space and Time Complexity

O(n^2)

Merge Sort (需要掌握 | 最快)


  Merge Sort is a Divide and Conquer algorithm.
  简单来说就是用二分法把这个array不断二分, 最后分成一个数的时候再互相比较重新拼回去.
  Merge sort 是递归. 值得刷!
  Best Merge Sort guid I found on Internet


Algorithm

MergeSort(arr[], l,  r)
If r &gt; l


  Find the middle point to divide the array into two halves:
     middle m = (l+r)/2
  Call mergeSort for first half: 
     Call mergeSort(arr, l, m)
  Call mergeSort for second half:
     Call mergeSort(arr, m+1, r)
  Merge the two halves sorted in step 2 and 3:
     Call merge(arr, l, m, r)




Code

public class CS627_AS02 {
    // Main function that sorts arr[l..r] using
// merge()
    void sort(int arr[], int l, int r)
    {
        if (l &lt; r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            // 注意!! 看这个recursive, 这里是用的近似于DFS的搜索, 搜到第一个, 然后再merge.
            //  一个对merge的错误印象是先divide后combine, 而其实是divide, combine同时进行.
            // 脑子里可以再仔细想想这个recursion, 也可以回去看一下DFS. 递归需要思考.
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

    // Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i &lt; n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j &lt; n2; ++j)
            R[j] = arr[m + 1 + j];

        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;

    /* 注意!! 当年学的时候比较疑惑, 两个array combine的时候不应该还是O(n^2)吗?
    	其实不然, 两个unsorted array才是O(n^2).  两个sorted array combine 用这个while loop O(n)就够了.
   	*/
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (L[i] &lt;= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i &lt; n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j &lt; n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Driver method
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6, 7 };

        System.out.println("Given Array");
        //printArray(arr);

        CS627_AS02 ob = new CS627_AS02();
        ob.sort(arr, 0, arr.length - 1);

        String arrayString = "";
        for(int i=0; i&lt;arr.length;i++)
        {
            arrayString = arrayString + arr[i] + ",";
        }

        System.out.println(arrayString.substring(0, arrayString.length() - 1));
    }
}


Space and Time Complexity

As we have already learned in Binary Search that whenever we divide a number into half in every stpe, it can be represented using a logarithmic function, which is log n and the number of steps can be represented by log n + 1 (at most)

Also, we perform a single step operation to find out the middle of any subarray, i.e. O(1).

And to merge the subarrays, made by dividing the original array of n elements, a running time of O(n) will be required.

Hence the total time for mergeSort function will become n(log n + 1), which gives us a time complexity of O(n*log n).



  
    Worst Case Time Complexity [ Big-O ]: O(n*log n)
  
  
    Best Case Time Complexity [Big-omega]: O(n*log n)
  
  
    Average Time Complexity [Big-theta]: O(n*log n)
  
  
    Space Complexity: O(n)
  


Quick Sort


  跟 merge sort 一样是divide and conquer
  相较于merge sort直接二分, quick是选一个节点进行比较, 然后把节点放在对的位置, 保证节点前比其小, 后面比节点都大, 之后再进行二分.
  选节点pivot的方法可以自由发挥, 没有固定规定.
  与merge sort的不同在于拼回去的过程之中无需再比较


Algorithm

这个图中里选用的事最后一个数作为节点.



Code

/* This function takes last element as pivot, 
   places the pivot element at its correct 
   position in sorted array, and places all 
   smaller (smaller than pivot) to left of 
   pivot and all greater elements to right 
   of pivot */
int partition(int arr[], int low, int high) 
{ 
    int pivot = arr[high];  
    int i = (low-1); // index of smaller element 
    for (int j=low; j&lt;high; j++) 
    { 
        // If current element is smaller than the pivot 
        if (arr[j] &lt; pivot) 
        { 
            i++; 
  
            // swap arr[i] and arr[j] 
            int temp = arr[i]; 
            arr[i] = arr[j]; 
            arr[j] = temp; 
        } 
    } 
  
    // swap arr[i+1] and arr[high] (or pivot) 
    int temp = arr[i+1]; 
    arr[i+1] = arr[high]; 
    arr[high] = temp; 
  
    return i+1; 
} 
  
  
/* The main function that implements QuickSort() 
  arr[] --&gt; Array to be sorted, 
  low  --&gt; Starting index, 
  high  --&gt; Ending index */
void sort(int arr[], int low, int high) 
{ 
    if (low &lt; high) 
    { 
        /* pi is partitioning index, arr[pi] is  
          now at right place */
        int pi = partition(arr, low, high); 
  
        // Recursively sort elements before 
        // partition and after partition 
        sort(arr, low, pi-1); 
        sort(arr, pi+1, high); 
    } 
} 


Space and Time Complexity

For an array, in which partitioning leads to unbalanced subarrays, to an extent where on the left side there are no elements, with all the elements greater than the pivot, hence on the right side.

And if keep on getting unbalanced subarrays, then the running time is the worst case, which is O(n^2)

Where as if partitioning leads to almost equal subarrays, then the running time is the best, with time complexity as O(n*log n).


  
    Worst Case Time Complexity [ Big-O ]: O(n2)
  
  
    Best Case Time Complexity [Big-omega]: O(n*log n)
  
  
    Average Time Complexity [Big-theta]: O(n*log n)
  
  
    Space Complexity: O(n*log n)
  


" />
    <meta property="og:description" content="Overview

Sorting 这一块就很搞笑. 学了多少次, 至少学了有3-4次了. 然后名字都知道, 就是记不住, 学了忘,忘了学. 最后就记住insertion和selection. 
这一次全部总结一下, 以后也就不用查了, 直接到这里看.

Bubble sort 是纯brutal force, selection sort稍微聪明一些, 也没好到哪里去.  Insertion sort完全在任何情况都比selection快. 所以其实这三种都可以不怎么看. 重点在于Merge sort, 既是divde&amp;conquer, 还考察recursive, 需要重点掌握.  Quick值得了解, 用的不多.

Bubble Sort

最基本的brutal force sorting, 任何场合都不会用到.   就是从头到尾一遍一遍的过n次, 如果前一个比后一个大就swap,直到没有swap为止.

Code

// An optimized version of Bubble Sort 
static void bubbleSort(int arr[], int n) 
{ 
    int i, j, temp; 
    boolean swapped; 
    for (i = 0; i &lt; n - 1; i++)  
    { 
    	// 此处用n-1次for loop可以保证最后一定sorting, 也可以用while(!swap), 效果是一样的
        swapped = false; 
        for (j = 0; j &lt; n - i - 1; j++)  
        { 
            if (arr[j] &gt; arr[j + 1])  
            { 
                // swap arr[j] and arr[j+1] 
                temp = arr[j]; 
                arr[j] = arr[j + 1]; 
                arr[j + 1] = temp; 
                swapped = true; 
            } 
        } 
  
        // IF no two elements were  
        // swapped by inner loop, then break 
        // 这是一个optimal的算法, 也可以不用swapped这个量, 直接走n次, 能保证最后一定是sorted. 
        if (swapped == false) 
            break; 
    } 
} 

Space and Time Complexity


  
    Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.
  
  
    Best Case Time Complexity: O(n). Best case occurs when array is already sorted.
  


Selection Sort

就是brutal,  两个for loop, 从头到尾刷一遍, 找最小, 塞到第一个, 然后再找最小, 塞到第二个, 以此类推.

Code

void selectionSort(int arr[], int n) 
{ 
    int i, j, min_idx; 
  
    // One by one move boundary of unsorted subarray 
    for (i = 0; i &lt; n-1; i++) 
    { 
        // Find the minimum element in unsorted array 
        min_idx = i; 
        for (j = i+1; j &lt; n; j++) 
          if (arr[j] &lt; arr[min_idx]) 
            min_idx = j; 
  
        // Swap the found minimum element with the first 
        // element 
        int temp = arr[min_idx]; 
        arr[min_idx] = arr[i]; 
        arr[i] = temp;
    } 
} 


Space and Time Complexity

O(n^2)

Insertion Sort

也很brutal, 整个array从头到尾刷一遍, 如果后一个比前一个小, 就用while loop跟上一个比较往前挪, 直到挪到适当的位置为止.

Algorithm

To sort an array of size n in ascending order:


  Iterate from arr[1] to arr[n] over the array.
  Compare the current element (key) to its predecessor.
  If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.




Code

    void sort(int arr[]) 
    { 
        int n = arr.length; 
        for (int i = 1; i &lt; n; ++i) { 
            int key = arr[i]; 
            int j = i - 1; 
  
            /* Move elements of arr[0..i-1], that are 
               greater than key, to one position ahead 
               of their current position */
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { 
                arr[j + 1] = arr[j]; 
                j = j - 1; 
            } 
            arr[j + 1] = key; 
        } 
    } 


Space and Time Complexity

O(n^2)

Merge Sort (需要掌握 | 最快)


  Merge Sort is a Divide and Conquer algorithm.
  简单来说就是用二分法把这个array不断二分, 最后分成一个数的时候再互相比较重新拼回去.
  Merge sort 是递归. 值得刷!
  Best Merge Sort guid I found on Internet


Algorithm

MergeSort(arr[], l,  r)
If r &gt; l


  Find the middle point to divide the array into two halves:
     middle m = (l+r)/2
  Call mergeSort for first half: 
     Call mergeSort(arr, l, m)
  Call mergeSort for second half:
     Call mergeSort(arr, m+1, r)
  Merge the two halves sorted in step 2 and 3:
     Call merge(arr, l, m, r)




Code

public class CS627_AS02 {
    // Main function that sorts arr[l..r] using
// merge()
    void sort(int arr[], int l, int r)
    {
        if (l &lt; r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            // 注意!! 看这个recursive, 这里是用的近似于DFS的搜索, 搜到第一个, 然后再merge.
            //  一个对merge的错误印象是先divide后combine, 而其实是divide, combine同时进行.
            // 脑子里可以再仔细想想这个recursion, 也可以回去看一下DFS. 递归需要思考.
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

    // Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i &lt; n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j &lt; n2; ++j)
            R[j] = arr[m + 1 + j];

        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;

    /* 注意!! 当年学的时候比较疑惑, 两个array combine的时候不应该还是O(n^2)吗?
    	其实不然, 两个unsorted array才是O(n^2).  两个sorted array combine 用这个while loop O(n)就够了.
   	*/
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (L[i] &lt;= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i &lt; n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j &lt; n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Driver method
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6, 7 };

        System.out.println("Given Array");
        //printArray(arr);

        CS627_AS02 ob = new CS627_AS02();
        ob.sort(arr, 0, arr.length - 1);

        String arrayString = "";
        for(int i=0; i&lt;arr.length;i++)
        {
            arrayString = arrayString + arr[i] + ",";
        }

        System.out.println(arrayString.substring(0, arrayString.length() - 1));
    }
}


Space and Time Complexity

As we have already learned in Binary Search that whenever we divide a number into half in every stpe, it can be represented using a logarithmic function, which is log n and the number of steps can be represented by log n + 1 (at most)

Also, we perform a single step operation to find out the middle of any subarray, i.e. O(1).

And to merge the subarrays, made by dividing the original array of n elements, a running time of O(n) will be required.

Hence the total time for mergeSort function will become n(log n + 1), which gives us a time complexity of O(n*log n).



  
    Worst Case Time Complexity [ Big-O ]: O(n*log n)
  
  
    Best Case Time Complexity [Big-omega]: O(n*log n)
  
  
    Average Time Complexity [Big-theta]: O(n*log n)
  
  
    Space Complexity: O(n)
  


Quick Sort


  跟 merge sort 一样是divide and conquer
  相较于merge sort直接二分, quick是选一个节点进行比较, 然后把节点放在对的位置, 保证节点前比其小, 后面比节点都大, 之后再进行二分.
  选节点pivot的方法可以自由发挥, 没有固定规定.
  与merge sort的不同在于拼回去的过程之中无需再比较


Algorithm

这个图中里选用的事最后一个数作为节点.



Code

/* This function takes last element as pivot, 
   places the pivot element at its correct 
   position in sorted array, and places all 
   smaller (smaller than pivot) to left of 
   pivot and all greater elements to right 
   of pivot */
int partition(int arr[], int low, int high) 
{ 
    int pivot = arr[high];  
    int i = (low-1); // index of smaller element 
    for (int j=low; j&lt;high; j++) 
    { 
        // If current element is smaller than the pivot 
        if (arr[j] &lt; pivot) 
        { 
            i++; 
  
            // swap arr[i] and arr[j] 
            int temp = arr[i]; 
            arr[i] = arr[j]; 
            arr[j] = temp; 
        } 
    } 
  
    // swap arr[i+1] and arr[high] (or pivot) 
    int temp = arr[i+1]; 
    arr[i+1] = arr[high]; 
    arr[high] = temp; 
  
    return i+1; 
} 
  
  
/* The main function that implements QuickSort() 
  arr[] --&gt; Array to be sorted, 
  low  --&gt; Starting index, 
  high  --&gt; Ending index */
void sort(int arr[], int low, int high) 
{ 
    if (low &lt; high) 
    { 
        /* pi is partitioning index, arr[pi] is  
          now at right place */
        int pi = partition(arr, low, high); 
  
        // Recursively sort elements before 
        // partition and after partition 
        sort(arr, low, pi-1); 
        sort(arr, pi+1, high); 
    } 
} 


Space and Time Complexity

For an array, in which partitioning leads to unbalanced subarrays, to an extent where on the left side there are no elements, with all the elements greater than the pivot, hence on the right side.

And if keep on getting unbalanced subarrays, then the running time is the worst case, which is O(n^2)

Where as if partitioning leads to almost equal subarrays, then the running time is the best, with time complexity as O(n*log n).


  
    Worst Case Time Complexity [ Big-O ]: O(n2)
  
  
    Best Case Time Complexity [Big-omega]: O(n*log n)
  
  
    Average Time Complexity [Big-theta]: O(n*log n)
  
  
    Space Complexity: O(n*log n)
  


" />
    
    <meta name="author" content="Jericho" />

    
    <meta property="og:title" content="Sorting" />
    <meta property="twitter:title" content="Sorting" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

<!--adobe fonts-->
<script>
    (function(d) {
      var config = {
        kitId: 'vbt3gjx',
        scriptTimeout: 3000,
        async: true
      },
      h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script> 

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/ShadowArchive/style.css" />
  <link rel="alternate" type="application/rss+xml" title="Jericho - 「さて、どこへ行こうかしらね。ネットは広大だわ」" href="/ShadowArchive/feed.xml" />
  <link rel="shortcut icon" href="https://github.com/easonback26/ShadowArchive/blob/master/images/favicon.png?raw=true">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://unpkg.com/feather-icons"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?...">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->


  <!-- Here for the Light Gallery-->
  

  

</head>

  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/ShadowArchive/" class="site-avatar"><img src="https://github.com/easonback26/ShadowArchive/blob/master/images/Black_Trinity_Logo.png?raw=true" /></a>
       
      <h1 class="site-name"><a href="/ShadowArchive/">Jericho</a></h1>
      <p class="site-description">「さて、どこへ行こうかしらね。ネットは広大だわ」</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/ShadowArchive/">ホーム</a>
      
      
      
      <a href="/ShadowArchive/about">関連</a>
      
      
      
      <a href="/ShadowArchive/shortcuts">常備</a>
      
      
      
      <a href="/ShadowArchive/archive">归档</a>
      
      
      
      <a href="/ShadowArchive/photo">写真</a>
      
      
      
      <a href="/ShadowArchive/tags">付箋</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:contactshadowsong@gmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/easonback26" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright (c) 2020 Shadow Walker</p>

    </footer>
  </div>
</div>

    
      <aside class="toc">
        <ul>
  <li><a href="#">Sorting</a>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#bubble-sort">Bubble Sort</a>
        <ul>
          <li><a href="#code">Code</a></li>
          <li><a href="#space-and-time-complexity">Space and Time Complexity</a></li>
        </ul>
      </li>
      <li><a href="#selection-sort">Selection Sort</a>
        <ul>
          <li><a href="#code-1">Code</a></li>
          <li><a href="#space-and-time-complexity-1">Space and Time Complexity</a></li>
        </ul>
      </li>
      <li><a href="#insertion-sort">Insertion Sort</a>
        <ul>
          <li><a href="#algorithm">Algorithm</a></li>
          <li><a href="#code-2">Code</a></li>
          <li><a href="#space-and-time-complexity-2">Space and Time Complexity</a></li>
        </ul>
      </li>
      <li><a href="#merge-sort-需要掌握--最快">Merge Sort (需要掌握 | 最快)</a>
        <ul>
          <li><a href="#algorithm-1">Algorithm</a></li>
          <li><a href="#code-3">Code</a></li>
          <li><a href="#space-and-time-complexity-3">Space and Time Complexity</a></li>
        </ul>
      </li>
      <li><a href="#quick-sort">Quick Sort</a>
        <ul>
          <li><a href="#algorithm-2">Algorithm</a></li>
          <li><a href="#code-4">Code</a></li>
          <li><a href="#space-and-time-complexity-4">Space and Time Complexity</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
      </aside>
    

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        <article class="posts">
  <h1>Sorting</h1>

  <div clsss="meta">
    <span class="author">
      Shadow Walker
    </span>

    <span class="date">
      2020-08-21
    </span>

    <ul class="tag">
      
      <li>
        <a href="http://localhost:4000/ShadowArchive/tags#Algorithm">
          Algorithm
        </a>
      </li>
      
      <li>
        <a href="http://localhost:4000/ShadowArchive/tags#Interview">
          Interview
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <h2 id="overview">Overview</h2>

<p>Sorting 这一块就很搞笑. 学了多少次, 至少学了有3-4次了. 然后名字都知道, 就是记不住, 学了忘,忘了学. 最后就记住insertion和selection. <br />
这一次全部总结一下, 以后也就不用查了, 直接到这里看.</p>

<p>Bubble sort 是纯brutal force, selection sort稍微聪明一些, 也没好到哪里去.  Insertion sort完全在任何情况都比selection快. 所以其实这三种都可以不怎么看. <strong>重点在于Merge sort</strong>, 既是divde&amp;conquer, 还考察recursive, 需要重点掌握.  Quick值得了解, 用的不多.</p>

<h2 id="bubble-sort">Bubble Sort</h2>

<p>最基本的brutal force sorting, 任何场合都不会用到.   就是从头到尾一遍一遍的过n次, 如果前一个比后一个大就swap,直到没有swap为止.</p>

<h3 id="code">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An optimized version of Bubble Sort </span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">temp</span><span class="o">;</span> 
    <span class="kt">boolean</span> <span class="n">swapped</span><span class="o">;</span> 
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>  
    <span class="o">{</span> 
    	<span class="c1">// 此处用n-1次for loop可以保证最后一定sorting, 也可以用while(!swap), 效果是一样的</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>  
        <span class="o">{</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>  
            <span class="o">{</span> 
                <span class="c1">// swap arr[j] and arr[j+1] </span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> 
                <span class="n">swapped</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 
            <span class="o">}</span> 
        <span class="o">}</span> 
  
        <span class="c1">// IF no two elements were  </span>
        <span class="c1">// swapped by inner loop, then break </span>
        <span class="c1">// 这是一个optimal的算法, 也可以不用swapped这个量, 直接走n次, 能保证最后一定是sorted. </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">swapped</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> 
            <span class="k">break</span><span class="o">;</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>
<h3 id="space-and-time-complexity">Space and Time Complexity</h3>

<ul>
  <li>
    <p>Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.</p>
  </li>
  <li>
    <p>Best Case Time Complexity: O(n). Best case occurs when array is already sorted.</p>
  </li>
</ul>

<h2 id="selection-sort">Selection Sort</h2>

<p>就是brutal,  两个for loop, 从头到尾刷一遍, 找最小, 塞到第一个, 然后再找最小, 塞到第二个, 以此类推.</p>

<h3 id="code-1">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">min_idx</span><span class="o">;</span> 
  
    <span class="c1">// One by one move boundary of unsorted subarray </span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> 
    <span class="o">{</span> 
        <span class="c1">// Find the minimum element in unsorted array </span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> 
          <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">min_idx</span><span class="o">])</span> 
            <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> 
  
        <span class="c1">// Swap the found minimum element with the first </span>
        <span class="c1">// element </span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">min_idx</span><span class="o">];</span> 
        <span class="n">arr</span><span class="o">[</span><span class="n">min_idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>

<h3 id="space-and-time-complexity-1">Space and Time Complexity</h3>

<p>O(n^2)</p>

<h2 id="insertion-sort">Insertion Sort</h2>

<p>也很brutal, 整个array从头到尾刷一遍, 如果后一个比前一个小, 就用while loop跟上一个比较往前挪, 直到挪到适当的位置为止.</p>

<h3 id="algorithm">Algorithm</h3>

<p>To sort an array of size n in ascending order:</p>

<ol>
  <li>Iterate from arr[1] to arr[n] over the array.</li>
  <li>Compare the current element (key) to its predecessor.</li>
  <li>If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.</li>
</ol>

<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png" alt="" /></p>

<h3 id="code-2">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[])</span> 
    <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span> 
            <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> 
  
            <span class="cm">/* Move elements of arr[0..i-1], that are 
               greater than key, to one position ahead 
               of their current position */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> 
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> 
            <span class="o">}</span> 
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
</code></pre></div></div>

<h3 id="space-and-time-complexity-2">Space and Time Complexity</h3>

<p>O(n^2)</p>

<h2 id="merge-sort-需要掌握--最快">Merge Sort (需要掌握 | 最快)</h2>

<ul>
  <li>Merge Sort is a Divide and Conquer algorithm.</li>
  <li>简单来说就是用二分法把这个array不断二分, 最后分成一个数的时候再互相比较重新拼回去.</li>
  <li><strong>Merge sort 是递归. 值得刷!</strong></li>
  <li><a href="https://www.studytonight.com/data-structures/merge-sort#:~:text=Time%20complexity%20of%20Merge%20Sort,space%20as%20the%20unsorted%20array.">Best Merge Sort guid I found on Internet</a></li>
</ul>

<h3 id="algorithm-1">Algorithm</h3>

<p>MergeSort(arr[], l,  r)<br />
If r &gt; l</p>

<ol>
  <li>Find the middle point to divide the array into two halves:<br />
     middle m = (l+r)/2</li>
  <li>Call mergeSort for first half: <br />
     Call mergeSort(arr, l, m)</li>
  <li>Call mergeSort for second half:
     Call mergeSort(arr, m+1, r)</li>
  <li>Merge the two halves sorted in step 2 and 3:
     Call merge(arr, l, m, r)</li>
</ol>

<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png" alt="" /></p>

<h3 id="code-3">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CS627_AS02</span> <span class="o">{</span>
    <span class="c1">// Main function that sorts arr[l..r] using</span>
<span class="c1">// merge()</span>
    <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Find the middle point</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="c1">// Sort first and second halves</span>
            <span class="c1">// 注意!! 看这个recursive, 这里是用的近似于DFS的搜索, 搜到第一个, 然后再merge.</span>
            <span class="c1">//  一个对merge的错误印象是先divide后combine, 而其实是divide, combine同时进行.</span>
            <span class="c1">// 脑子里可以再仔细想想这个recursion, 也可以回去看一下DFS. 递归需要思考.</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>

            <span class="c1">// Merge the sorted halves</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Merges two subarrays of arr[].</span>
<span class="c1">// First subarray is arr[l..m]</span>
<span class="c1">// Second subarray is arr[m+1..r]</span>
    <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// Find sizes of two subarrays to be merged</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">m</span><span class="o">;</span>

        <span class="cm">/* Create temp arrays */</span>
        <span class="kt">int</span> <span class="no">L</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="no">R</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n2</span><span class="o">];</span>

        <span class="cm">/*Copy data to temp arrays*/</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span>
            <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">j</span><span class="o">];</span>

        <span class="cm">/* Merge the temp arrays */</span>

        <span class="c1">// Initial indexes of first and second subarrays</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// Initial index of merged subarry array</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>

    <span class="cm">/* 注意!! 当年学的时候比较疑惑, 两个array combine的时候不应该还是O(n^2)吗?
    	其实不然, 两个unsorted array才是O(n^2).  两个sorted array combine 用这个while loop O(n)就够了.
   	*/</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="cm">/* Copy remaining elements of L[] if any */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">L</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="cm">/* Copy remaining elements of R[] if any */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">j</span><span class="o">++;</span>
            <span class="n">k</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Driver method</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span> <span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Given Array"</span><span class="o">);</span>
        <span class="c1">//printArray(arr);</span>

        <span class="no">CS627_AS02</span> <span class="n">ob</span> <span class="o">=</span> <span class="k">new</span> <span class="no">CS627_AS02</span><span class="o">();</span>
        <span class="n">ob</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

        <span class="nc">String</span> <span class="n">arrayString</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="n">arrayString</span> <span class="o">=</span> <span class="n">arrayString</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">","</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arrayString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">arrayString</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="space-and-time-complexity-3">Space and Time Complexity</h3>

<p>As we have already learned in Binary Search that whenever we divide a number into half in every stpe, it can be represented using a logarithmic function, which is <code class="language-plaintext highlighter-rouge">log n </code>and the number of steps can be represented by <code class="language-plaintext highlighter-rouge">log n + 1</code> (at most)</p>

<p>Also, we perform a single step operation to find out the middle of any subarray, i.e. <code class="language-plaintext highlighter-rouge">O(1)</code>.</p>

<p>And to merge the subarrays, made by dividing the original array of <code class="language-plaintext highlighter-rouge">n</code> elements, a running time of <code class="language-plaintext highlighter-rouge">O(n)</code> will be required.</p>

<p>Hence the total time for <code class="language-plaintext highlighter-rouge">mergeSort</code> function will become <code class="language-plaintext highlighter-rouge">n(log n + 1)</code>, which gives us a time complexity of <code class="language-plaintext highlighter-rouge">O(n*log n)</code>.
<br /><br /><br /></p>

<ul>
  <li>
    <p>Worst Case Time Complexity [ Big-O ]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Best Case Time Complexity [Big-omega]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Average Time Complexity [Big-theta]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Space Complexity: <code class="language-plaintext highlighter-rouge">O(n)</code></p>
  </li>
</ul>

<h2 id="quick-sort">Quick Sort</h2>

<ul>
  <li>跟 merge sort 一样是divide and conquer</li>
  <li>相较于merge sort直接二分, quick是选一个节点进行比较, 然后把节点放在对的位置, 保证节点前比其小, 后面比节点都大, 之后再进行二分.</li>
  <li>选节点pivot的方法可以自由发挥, 没有固定规定.</li>
  <li>与merge sort的不同在于拼回去的过程之中无需再比较</li>
</ul>

<h3 id="algorithm-2">Algorithm</h3>

<p>这个图中里选用的事最后一个数作为节点.</p>

<p><img src="../uploads/3odpn7gl8myiqx7rto4f.png" alt="Quick Sort Illustration" /></p>

<h3 id="code-4">Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* This function takes last element as pivot, 
   places the pivot element at its correct 
   position in sorted array, and places all 
   smaller (smaller than pivot) to left of 
   pivot and all greater elements to right 
   of pivot */</span>
<span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>  
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// index of smaller element </span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">high</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> 
    <span class="o">{</span> 
        <span class="c1">// If current element is smaller than the pivot </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="n">i</span><span class="o">++;</span> 
  
            <span class="c1">// swap arr[i] and arr[j] </span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> 
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
  
    <span class="c1">// swap arr[i+1] and arr[high] (or pivot) </span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span> 
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">];</span> 
    <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span> 
  
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> 
<span class="o">}</span> 
  
  
<span class="cm">/* The main function that implements QuickSort() 
  arr[] --&gt; Array to be sorted, 
  low  --&gt; Starting index, 
  high  --&gt; Ending index */</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* pi is partitioning index, arr[pi] is  
          now at right place */</span>
        <span class="kt">int</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span> 
  
        <span class="c1">// Recursively sort elements before </span>
        <span class="c1">// partition and after partition </span>
        <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pi</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> 
        <span class="n">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>

<h3 id="space-and-time-complexity-4">Space and Time Complexity</h3>

<p>For an array, in which partitioning leads to unbalanced subarrays, to an extent where on the left side there are no elements, with all the elements greater than the pivot, hence on the right side.</p>

<p>And if keep on getting unbalanced subarrays, then the running time is the worst case, which is <code class="language-plaintext highlighter-rouge">O(n^2)</code></p>

<p>Where as if partitioning leads to almost equal subarrays, then the running time is the best, with time complexity as <code class="language-plaintext highlighter-rouge">O(n*log n)</code>.</p>

<ul>
  <li>
    <p>Worst Case Time Complexity [ Big-O ]: <code class="language-plaintext highlighter-rouge">O(n2)</code></p>
  </li>
  <li>
    <p>Best Case Time Complexity [Big-omega]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Average Time Complexity [Big-theta]: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
  <li>
    <p>Space Complexity: <code class="language-plaintext highlighter-rouge">O(n*log n)</code></p>
  </li>
</ul>


  </div>


  <!-- 现在不用disqus评论了, 想用可以加上 评论区只有最上面comment true的时候才能用-->
  
<div class="comments">
    <div id="gitalk-container"></div>
    <script>
        const gitalk = new Gitalk({
          clientID: "ecd5f9ca822b01f65e22",
          clientSecret: "954fc161c6daece1d5d57bfc82d593a045d18551",
          repo: "ShadowArchive",
          owner: "easonback26",
          admin: ["easonback26"],
          id: window.location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false,  // Facebook-like distraction free mode
          title: "Sorting",
          language: "ja",

        })
        
        gitalk.render('gitalk-container')
    </script>
</div>

</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="http://localhost:4000/ShadowArchive/%E5%9C%A8%E7%BE%8E%E5%9B%BD%E5%81%9A%E7%A9%B7%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/">
        ← 前に
      </a>
    </span>
  
  
    <span class="next" >
      <a href="http://localhost:4000/ShadowArchive/VisaQuestions/">
        次に →
      </a>
    </span>
  
</div>

<style>
.videoWrapper {
	position: relative;
	padding-bottom: 56.333%;
	height: 0;
    background: black;
}
.videoWrapper iframe {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
    border: 0;
}    
</style>

<script>
function get_youtube_id(url) {
    var p = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
    return (url.match(p)) ? RegExp.$1 : false;
}
function vimeo_embed(url,el) {
    var id = false;
    $.ajax({
      url: 'https://vimeo.com/api/oembed.json?url='+url,
      async: true,
      success: function(response) {
        if(response.video_id) {
          id = response.video_id;
          if(url.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0;
          if(url.indexOf('loop=1') !== -1) var loop=1; else var loop=0;
          var theInnerHTML = '<div class="videoWrapper"><iframe src="https://player.vimeo.com/video/'+id+'/?byline=0&title=0&portrait=0';
          if(autoplay==1) theInnerHTML += '&autoplay=1';
          if(loop==1) theInnerHTML += '&loop=1';
          theInnerHTML += '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>'; 
          el.innerHTML = theInnerHTML;
        }
      }
    });
}
function video_embed() {
    var p = document.getElementsByTagName('p');
    for(var i = 0; i < p.length; i++) {
        //check if this is an external url (that starts with https:// or http://
        if (p[i].innerHTML.indexOf("http://") == 0 ||
            p[i].innerHTML.indexOf("https://") == 0) {
            var youtube_id = get_youtube_id(p[i].innerHTML);
            if(youtube_id) {
                if(p[i].innerHTML.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0;
                if(p[i].innerHTML.indexOf('loop=1') !== -1) var loop=1; else var loop=0;
                var theInnerHTML = '<div class="videoWrapper"><iframe width="720" height="420" src="https://www.youtube.com/embed/' + youtube_id + '?rel=0&showinfo=0';
                if(autoplay==1) theInnerHTML += '&autoplay=1';
                if(loop==1) theInnerHTML += '&loop=1&playlist='+youtube_id+'&version=3';
                if(p[i].innerHTML.indexOf('start=') !== -1) theInnerHTML += '&start='+p[i].innerHTML.substring(p[i].innerHTML.indexOf('start=')+6);
                theInnerHTML += '" frameborder="0" allowfullscreen></iframe></div>';
                p[i].innerHTML = theInnerHTML;
            }
            if(p[i].innerHTML.indexOf('vimeo.com') !== -1) {
                //ask vimeo for the id and place the embed
                vimeo_embed(p[i].innerHTML,p[i]);
            }
        }
    }
}
video_embed();

function mp3_embed() {
    var p = document.getElementsByTagName('p');
    for(var i = 0; i < p.length; i++) {
        if(p[i].innerHTML.indexOf('.mp3') !== -1) {
            var str = p[i].innerHTML.split('?');
            if(str.length == 1) str[1] = '';
            var str1 = str[1];
            str1 = str1.replace('&','').replace('&','');
            str1 = str1.replace('autoplay=1','').replace('autoplay=0','');
            str1 = str1.replace('loop=1','').replace('loop=0','');
            str1 = str1.replace('controls=0','').replace('controls=1','');

            if (str[0].lastIndexOf('.mp3', str[0].length - 4) === str[0].length - 4 && str1.length == 0) {
                if(str[1].indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0;
                if(str[1].indexOf('loop=1') !== -1) var loop=1; else var loop=0;
                if(str[1].indexOf('controls=0') !== -1) var controls=0; else var controls=1;
                var newInnerHTML = '<audio';
                if(autoplay==1) newInnerHTML += ' autoplay';
                if(loop==1) newInnerHTML += ' loop';
                if(controls==1) newInnerHTML += ' controls';
                newInnerHTML += '><source src="'+str[0]+'" type="audio/mpeg">Your browser does not support the audio element.</audio>';
                p[i].innerHTML = newInnerHTML;
            }
        }
    }
}
mp3_embed();
</script>





      </div>
    </div>

    



  </body>

  
  <script>
    document.getElementById("main").classList.add("withtoc");
  </script>
  

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:contactshadowsong@gmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/easonback26" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright (c) 2020 Shadow Walker</p>

    </footer>


</html>
