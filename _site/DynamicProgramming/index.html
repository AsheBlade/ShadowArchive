<!DOCTYPE html>
<html>
  <head>
  <title>Dynamic Programming – Jericho – 「さて、どこへ行こうかしらね。ネットは広大だわ」</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Overview

DP相关的问题一直是我比较吃力和难以理解的一块. 希望通过总结知识点和相关题目能够增强对DP问题的理解.

窍门:

如果写不出通式的话, 就从basic case一个一个写下去, 1,2,3,4, 多写几个就会有思路.

Fibonacci 类问题

Fibonacci类的DP有一系列问题. 这种问题的特点有几点:


  都是那种通过前后叠加去解决. 就是上楼梯问题.
  可以通过 Divide-Conquer 化解成 basic problem, 然后解决.
  表面上第一想到的通常用递归解决, 但用递归的话, 有指数复杂度.
  这一类我归结为单纯叠加, 不涉及Max和Min之类的问题, 相对来说比较简单.


Fibonacci

Description

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,


  F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N &gt; 1.


Given N, calculate F(N).

Solution

class Solution {
    public int fib(int N) {
        
        if (N == 0)
        {
            return 0;
        }
        
        if (N == 1)
        {
            return 1;
        }
        
        int[] dp = new int[N+1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i=2; i&lt;N+1; i++)
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[N];
    }
}


Climbing Stairs

Description

You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:


  Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
  
    1 step + 1 step
    2 steps
  


Example 2:


  Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
  
    1 step + 1 step + 1 step
    1 step + 2 steps
    2 steps + 1 step
  


Algorithm

As we can see this problem can be broken into subproblems, and it contains the optimal substructure property i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic programming to solve this problem.

One can reach ith step in one of the two ways:


  Taking a single step from (i-1)th step.
  Taking a step of 22 from (i-2)th step.


So, the total number of ways to reach ith is equal to sum of ways of reaching (i-1)th step and ways of reaching (i-2)th step.

Let dp[i] denotes the number of ways to reach on ith step:

dp[i]=dp[i-1]+dp[i-2]

Solution

class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}


叠加后求Max/Min问题

特点:


  DP 有一个basic case, 从basic case扩展出一个general case
  这一类可以算是Fibonacci之上扩展出求Max/Min的问题
  DP从头递增/递减才能够计算. 不存在从中间或者什么奇怪的地方突然冒出来的DP
  DP基本都会涉及到Max 和 Min, 在Java之中用的是: Math.max(a,b)
  基于第三点, DP的Max和Min存在叠加性, 即上一轮的Max可以保证这一轮的Max, 不存在诡异的地方影响. 这一点要牢记


House Robber

Description

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:


  Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.


Example 2:


  Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.


Algorithm

This problem is equal to given an array, the solution is to find the maximum sum subsequence where no two selected elements are adjacent. So the approach to the problem is a recursive solution. So there are two cases.

Basic case:

  no element, return 0;
  one element, return it.
  2 element, return max(first element, second element.


General:
Two ways to reach max for ith element.

  nums[i] + dp[i-2]
  dp[i-1]


比较这两种方法, 求二者之中的最大值, 即为dp[i].

Solution

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) 
        return 0; 
        if (n == 1) 
            return nums[0]; 
        if (n == 2) 
            return Math.max(nums[0], nums[1]); 
   
        // dp[i] represent the maximum value stolen 
        // so far after reaching house i. 
        int[] dp = new int[n]; 
   
        // Initialize the dp[0] and dp[1] 
        dp[0] = nums[0]; 
        dp[1] = Math.max(nums[0], nums[1]); 
   
        // Fill remaining positions 
        for (int i = 2; i&lt;n; i++) 
            dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); 
   
        return dp[n-1]; 
    }
}


分析

这道题的话, 我自己做的话, 第一次是想不到标准答案那么完美的情况. 
如下图, 我会考虑从D点出发,为了避免相邻, 有四种情况, 我会从四种情况之中求max.



如下, 是考虑了三中情况(图中1,3,4)而写出的答案.  但其实标准答案之中只考虑了三个量, 没有考虑A的存在, 因为A已经被其他dp包含了. 但其实并不用过度担心这种多写. 因为Max这个方法是不会增加算力的. 即便多考虑几种情况放到max之中, 在LC之中依然是比100%的人跑得快.  所以这里也是DP的一个特点, DP看起来都很吓人, 但多动笔写写base case其实很容易出来.

另, 这也就是Max问题和单纯Fibonacci的区别.  Fibonacci类需要考虑所有情况, 而Max类只需要考虑Max就可以.

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) 
        return 0; 
        if (n == 1) 
            return nums[0]; 
        if (n == 2) 
            return Math.max(nums[0], nums[1]); 

   
        // dp[i] represent the maximum value stolen 
        // so far after reaching house i. 
        int[] dp = new int[n]; 
   
        // Initialize the dp[0] and dp[1] 
        dp[0] = nums[0]; 
        dp[1] = Math.max(nums[0], nums[1]); 
        dp[2] = Math.max(nums[2]+dp[0], dp[1]);
   
        // Fill remaining positions 
        for (int i = 3; i&lt;n; i++) 
            //dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]);
            // 以上为标准答案的dp通式, 下面写的这个冗长, 考虑了三种, 但是不会增加算力. 
            dp[i] = Math.max(nums[i]+dp[i-3], Math.max(nums[i]+dp[i-2], dp[i-1]));
   
        return dp[n-1]; 
    }
}


Matrix dp 问题

这个类型的dp, 我还没想好是否单独分一个类. 其主要的特点就是由一个matrix dp去解决, 出现了二维化, 而不仅仅是前面的一维.

这一块是比较难了. 即使能想明白, 也不一定能写对, 即使能写对也不一定能在规定的时间内写对.  对这一块目前来说还是学习和了解为主, 不需要完全掌握.

其实如果真理解的话, 其实这一套和一维的也不见得有很大区别.最大区别也就是多了一个capacity的给定量. 上边的题目没有限制, 只要去max就可以了, 而这个不同, 在一个有限的范围内给出max. 从而要不断去track这个给定量. 只要抓住这个关键点, 思路就清晰了很多.

Non-Fractional Knapsack

关于这个问题, 这个guide写的最好了. 我下面的东西基本都是从这个guide里面来的, 改动很小.

Problem Description

Given the weights and profits of ‘N’ items, we are asked to put these items in a knapsack which has a capacity ‘C’. The goal is to get the maximum profit from the items in the knapsack. Each item can only be selected once, as we don’t have multiple quantities of any item.

Constraints:


  an item cannot be used more than twice.
  In the list, there is only one item for each weights.
  If you take an item, you have to take it as a whole (non-fractional).


Example:

Items: { Apple, Orange, Banana, Melon } 
Weights: { 2, 3, 1, 4 } 
Profits: { 4, 5, 3, 7 } 
Knapsack capacity: 5

We can have the following combinations:

Apple + Orange (total weight 5) =&gt; 9 profit 
Apple + Banana (total weight 3) =&gt; 7 profit 
Orange + Banana (total weight 4) =&gt; 8 profit 
Banana + Melon (total weight 5) =&gt; 10 profit

Algorithm

Essentially, we want to find the maximum profit for every sub-array and for every possible capacity. This means, dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.

So, for each item at index ‘i’ (0 &lt;= i &lt; items.length) and capacity‘c’ (0 &lt;= c &lt;= capacity) , we have two options:


  Exclude the item at index ‘i’. In this case, we will take whatever profit we get from the sub-array excluding this item =&gt; dp[i-1][c]
  Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items =&gt; profits[i] + dp[i-1][c-weights[i]]


其实从这里我们就可以看出, 二维和一维的情况是一样的, 无非两种情况, 选或者不选.  只不过多了一个capacity的量而已, 需要根据不同的capacity去track而已, 多了一个维度.

Finally, our optimal solution will be maximum of the above two values:

dp[i][c] = max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]]) 


Given input of :        ` int[] profits = {1, 6, 10, 16};   int[] weights = {1, 2, 3, 5};`, we have a matrix dp of such:



Code


  这个code没有递归的, 我觉得是我看过的比较简洁易懂的, 只用一个方法. traverse一遍而已. 没有浪费memory
  这个方法是从前往后走, 即从前往后走.
  这个guide之中给的例子的两个list都是sorted, 我不确定unsorted的时候这个方法还能不能用. 应该是不行.
  basic case 分为三步,


  	- check edge case, 各种等于0. 
- set column 0, 
- set row 0. 



  general case 就像前面说过的, 无非两种情况, traverse 到 ith item的时候只有两种情况: 选或者不选, 然后取max.
  代码很吓人, 但像之前说的其实只有两种情况, 多看几分钟结合那个图看自然就看懂了. 可以去guide看一眼, 里面有动画.


  public class KnapSack {

    public int solveKnapsack(int[] profits, int[] weights, int capacity) {
        // dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.

        // basic checks
        if (capacity &lt;= 0 || profits.length == 0 || weights.length != profits.length)
            return 0;

        int n = profits.length;
        int[][] dp = new int[n][capacity + 1];

        // populate the capacity=0 columns, with '0' capacity we have '0' profit
        for(int i=0; i &lt; n; i++)
            dp[i][0] = 0;
	
	  // Set row 0, i=0 means we are only allowed to take 0th item which is the first itme. 
        // if we can only take the first item, we will take it if it is not more than the capacity
        if(weights[0] &lt;= capacity)
        {
            for(int c=weights[0] ; c &lt;= capacity; c++) {
                dp[0][c] = profits[0];
            }
        }


        // process all sub-arrays for all the capacities
        for(int i=1; i &lt; n; i++) {
            for(int c=1; c &lt;= capacity; c++) {
                int profit1= 0, profit2 = 0;
                // include the item, if it is not more than the capacity
                if(weights[i] &lt;= c)
                    profit1 = profits[i] + dp[i-1][c-weights[i]];
                // exclude the item
                profit2 = dp[i-1][c];
                // take maximum
                dp[i][c] = Math.max(profit1, profit2);
            }
        }

        // maximum profit will be at the bottom-right corner.
        return dp[n-1][capacity];
    }

    public static void main(String[] args) {
        KnapSack ks = new KnapSack();
        int[] profits = {1, 6, 10, 16};
        int[] weights = {1, 2, 3, 5};

        int maxProfit = ks.solveKnapsack(profits, weights, 7);
        System.out.println("Total knapsack profit ---&gt; " + maxProfit);

        maxProfit = ks.solveKnapsack(profits, weights, 6);
        System.out.println("Total knapsack profit ---&gt; " + maxProfit);
    }
}


Longest Palindromic Substring LC_005

Problem Description

Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:


  Input: “babad”
Output: “bab”
Note: “aba” is also a valid answer.


Example 2:


  Input: “cbbd”
Output: “bb”


Algorithm

code来自于GeeksforGeeks.

这一道的难点在于这个DP general case即使从一开始一个一个从base case开始写也想不出来.  不过其实这种问题很多Matrix DP都是存在的. 上一道其实还容易想一点, 因为是先把column0, row0 都set之后才开始做general case, 不用担心不存在的情况. 这道的话, 是从对角线开始set的, 如果从矩阵的层面去思考的话, 想半天可能都想不明白为什么能保证后面的dp一定被set.

换个思路, 这么想: 先set所有长度是1的, 然后是所有长度是2的. 后面从3开始, 自然会track以前1和2的, 然而1和2的都已经被set了. 4的话从3开始track, 而3都被set了.  这么想就容易很多.  这道的切入点是从每个subString的length, 这个思路很难想到.

最后想说这个不管怎么说还是没有递归的, 拿笔写几下会想的会更清楚. 干看的话看半天也不一定能看明白.

Solution

// Java Solution 
public class LongestPalinSubstring { 
	// A utility function to print 
	// a substring str[low..high] 
	static void printSubStr( 
		String str, int low, int high) 
	{ 
		System.out.println( 
			str.substring( 
				low, high + 1)); 
	} 

	// This function prints the longest 
	// palindrome substring of str[]. 
	// It also returns the length of the 
	// longest palindrome 
	static int longestPalSubstr(String str) 
	{ 
		// get length of input string 
		int n = str.length(); 

		// table[i][j] will be false if 
		// substring str[i..j] is not palindrome. 
		// Else table[i][j] will be true 
		boolean table[][] = new boolean[n][n]; 

		// All substrings of length 1 are palindromes 
		// 把对角线set, 每个dp[i][i] 里面只有一个元素肯定是true的
		int maxLength = 1; 
		for (int i = 0; i &lt; n; ++i) 
			table[i][i] = true; 

		// check for sub-string of length 2. 
		// 一个元素的set之后, 去set二元素的, 因为一个元素都解决了, 两个元素都是在一个元素基础之上的, 肯定是存在的. 
		int start = 0; 
		for (int i = 0; i &lt; n - 1; ++i) { 
			if (str.charAt(i) == str.charAt(i + 1)) { 
				table[i][i + 1] = true; 
				start = i; 
				maxLength = 2; 
			} 
		} 

		// Check for lengths greater than 2. 
		// k is length of substring  k是长度

		for (int k = 3; k &lt;= n; ++k) { 
			// Fix the starting index 
			// 这个算法比较特别, 是从每个string的长度去track的. 长度从小到大. 简而言之是check每个给定长度的所有可能的substring. 
			for (int i = 0; i &lt; n - k + 1; ++i) { 
				// Get the ending index of substring from 
				// starting index i and length k 
				int j = i + k - 1; 

				// checking for sub-string from ith index to 
				// jth index iff str.charAt(i+1) to 
				// str.charAt(j-1) is a palindrome 
				if (table[i + 1][j - 1] 
					&amp;&amp; str.charAt(i) == str.charAt(j)) { 
					table[i][j] = true; 

					if (k &gt; maxLength) { 
						start = i; 
						maxLength = k; 
					} 
				} 
			} 
		} 
		System.out.print("Longest palindrome substring is; "); 
		printSubStr(str, start, 
					start + maxLength - 1); 

		// return length of LPS 
		return maxLength; 
	} 

	// Driver program to test above functions 
	public static void main(String[] args) 
	{ 

		String str = "forgeeksskeegfor"; 
		System.out.println("Length is: " + longestPalSubstr(str)); 
	} 
} 

// This code is contributed by Sumit Ghosh 



Coin Machine
" />
    <meta property="og:description" content="Overview

DP相关的问题一直是我比较吃力和难以理解的一块. 希望通过总结知识点和相关题目能够增强对DP问题的理解.

窍门:

如果写不出通式的话, 就从basic case一个一个写下去, 1,2,3,4, 多写几个就会有思路.

Fibonacci 类问题

Fibonacci类的DP有一系列问题. 这种问题的特点有几点:


  都是那种通过前后叠加去解决. 就是上楼梯问题.
  可以通过 Divide-Conquer 化解成 basic problem, 然后解决.
  表面上第一想到的通常用递归解决, 但用递归的话, 有指数复杂度.
  这一类我归结为单纯叠加, 不涉及Max和Min之类的问题, 相对来说比较简单.


Fibonacci

Description

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,


  F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N &gt; 1.


Given N, calculate F(N).

Solution

class Solution {
    public int fib(int N) {
        
        if (N == 0)
        {
            return 0;
        }
        
        if (N == 1)
        {
            return 1;
        }
        
        int[] dp = new int[N+1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i=2; i&lt;N+1; i++)
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[N];
    }
}


Climbing Stairs

Description

You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:


  Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
  
    1 step + 1 step
    2 steps
  


Example 2:


  Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
  
    1 step + 1 step + 1 step
    1 step + 2 steps
    2 steps + 1 step
  


Algorithm

As we can see this problem can be broken into subproblems, and it contains the optimal substructure property i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic programming to solve this problem.

One can reach ith step in one of the two ways:


  Taking a single step from (i-1)th step.
  Taking a step of 22 from (i-2)th step.


So, the total number of ways to reach ith is equal to sum of ways of reaching (i-1)th step and ways of reaching (i-2)th step.

Let dp[i] denotes the number of ways to reach on ith step:

dp[i]=dp[i-1]+dp[i-2]

Solution

class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}


叠加后求Max/Min问题

特点:


  DP 有一个basic case, 从basic case扩展出一个general case
  这一类可以算是Fibonacci之上扩展出求Max/Min的问题
  DP从头递增/递减才能够计算. 不存在从中间或者什么奇怪的地方突然冒出来的DP
  DP基本都会涉及到Max 和 Min, 在Java之中用的是: Math.max(a,b)
  基于第三点, DP的Max和Min存在叠加性, 即上一轮的Max可以保证这一轮的Max, 不存在诡异的地方影响. 这一点要牢记


House Robber

Description

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:


  Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.


Example 2:


  Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.


Algorithm

This problem is equal to given an array, the solution is to find the maximum sum subsequence where no two selected elements are adjacent. So the approach to the problem is a recursive solution. So there are two cases.

Basic case:

  no element, return 0;
  one element, return it.
  2 element, return max(first element, second element.


General:
Two ways to reach max for ith element.

  nums[i] + dp[i-2]
  dp[i-1]


比较这两种方法, 求二者之中的最大值, 即为dp[i].

Solution

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) 
        return 0; 
        if (n == 1) 
            return nums[0]; 
        if (n == 2) 
            return Math.max(nums[0], nums[1]); 
   
        // dp[i] represent the maximum value stolen 
        // so far after reaching house i. 
        int[] dp = new int[n]; 
   
        // Initialize the dp[0] and dp[1] 
        dp[0] = nums[0]; 
        dp[1] = Math.max(nums[0], nums[1]); 
   
        // Fill remaining positions 
        for (int i = 2; i&lt;n; i++) 
            dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); 
   
        return dp[n-1]; 
    }
}


分析

这道题的话, 我自己做的话, 第一次是想不到标准答案那么完美的情况. 
如下图, 我会考虑从D点出发,为了避免相邻, 有四种情况, 我会从四种情况之中求max.



如下, 是考虑了三中情况(图中1,3,4)而写出的答案.  但其实标准答案之中只考虑了三个量, 没有考虑A的存在, 因为A已经被其他dp包含了. 但其实并不用过度担心这种多写. 因为Max这个方法是不会增加算力的. 即便多考虑几种情况放到max之中, 在LC之中依然是比100%的人跑得快.  所以这里也是DP的一个特点, DP看起来都很吓人, 但多动笔写写base case其实很容易出来.

另, 这也就是Max问题和单纯Fibonacci的区别.  Fibonacci类需要考虑所有情况, 而Max类只需要考虑Max就可以.

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) 
        return 0; 
        if (n == 1) 
            return nums[0]; 
        if (n == 2) 
            return Math.max(nums[0], nums[1]); 

   
        // dp[i] represent the maximum value stolen 
        // so far after reaching house i. 
        int[] dp = new int[n]; 
   
        // Initialize the dp[0] and dp[1] 
        dp[0] = nums[0]; 
        dp[1] = Math.max(nums[0], nums[1]); 
        dp[2] = Math.max(nums[2]+dp[0], dp[1]);
   
        // Fill remaining positions 
        for (int i = 3; i&lt;n; i++) 
            //dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]);
            // 以上为标准答案的dp通式, 下面写的这个冗长, 考虑了三种, 但是不会增加算力. 
            dp[i] = Math.max(nums[i]+dp[i-3], Math.max(nums[i]+dp[i-2], dp[i-1]));
   
        return dp[n-1]; 
    }
}


Matrix dp 问题

这个类型的dp, 我还没想好是否单独分一个类. 其主要的特点就是由一个matrix dp去解决, 出现了二维化, 而不仅仅是前面的一维.

这一块是比较难了. 即使能想明白, 也不一定能写对, 即使能写对也不一定能在规定的时间内写对.  对这一块目前来说还是学习和了解为主, 不需要完全掌握.

其实如果真理解的话, 其实这一套和一维的也不见得有很大区别.最大区别也就是多了一个capacity的给定量. 上边的题目没有限制, 只要去max就可以了, 而这个不同, 在一个有限的范围内给出max. 从而要不断去track这个给定量. 只要抓住这个关键点, 思路就清晰了很多.

Non-Fractional Knapsack

关于这个问题, 这个guide写的最好了. 我下面的东西基本都是从这个guide里面来的, 改动很小.

Problem Description

Given the weights and profits of ‘N’ items, we are asked to put these items in a knapsack which has a capacity ‘C’. The goal is to get the maximum profit from the items in the knapsack. Each item can only be selected once, as we don’t have multiple quantities of any item.

Constraints:


  an item cannot be used more than twice.
  In the list, there is only one item for each weights.
  If you take an item, you have to take it as a whole (non-fractional).


Example:

Items: { Apple, Orange, Banana, Melon } 
Weights: { 2, 3, 1, 4 } 
Profits: { 4, 5, 3, 7 } 
Knapsack capacity: 5

We can have the following combinations:

Apple + Orange (total weight 5) =&gt; 9 profit 
Apple + Banana (total weight 3) =&gt; 7 profit 
Orange + Banana (total weight 4) =&gt; 8 profit 
Banana + Melon (total weight 5) =&gt; 10 profit

Algorithm

Essentially, we want to find the maximum profit for every sub-array and for every possible capacity. This means, dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.

So, for each item at index ‘i’ (0 &lt;= i &lt; items.length) and capacity‘c’ (0 &lt;= c &lt;= capacity) , we have two options:


  Exclude the item at index ‘i’. In this case, we will take whatever profit we get from the sub-array excluding this item =&gt; dp[i-1][c]
  Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items =&gt; profits[i] + dp[i-1][c-weights[i]]


其实从这里我们就可以看出, 二维和一维的情况是一样的, 无非两种情况, 选或者不选.  只不过多了一个capacity的量而已, 需要根据不同的capacity去track而已, 多了一个维度.

Finally, our optimal solution will be maximum of the above two values:

dp[i][c] = max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]]) 


Given input of :        ` int[] profits = {1, 6, 10, 16};   int[] weights = {1, 2, 3, 5};`, we have a matrix dp of such:



Code


  这个code没有递归的, 我觉得是我看过的比较简洁易懂的, 只用一个方法. traverse一遍而已. 没有浪费memory
  这个方法是从前往后走, 即从前往后走.
  这个guide之中给的例子的两个list都是sorted, 我不确定unsorted的时候这个方法还能不能用. 应该是不行.
  basic case 分为三步,


  	- check edge case, 各种等于0. 
- set column 0, 
- set row 0. 



  general case 就像前面说过的, 无非两种情况, traverse 到 ith item的时候只有两种情况: 选或者不选, 然后取max.
  代码很吓人, 但像之前说的其实只有两种情况, 多看几分钟结合那个图看自然就看懂了. 可以去guide看一眼, 里面有动画.


  public class KnapSack {

    public int solveKnapsack(int[] profits, int[] weights, int capacity) {
        // dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.

        // basic checks
        if (capacity &lt;= 0 || profits.length == 0 || weights.length != profits.length)
            return 0;

        int n = profits.length;
        int[][] dp = new int[n][capacity + 1];

        // populate the capacity=0 columns, with '0' capacity we have '0' profit
        for(int i=0; i &lt; n; i++)
            dp[i][0] = 0;
	
	  // Set row 0, i=0 means we are only allowed to take 0th item which is the first itme. 
        // if we can only take the first item, we will take it if it is not more than the capacity
        if(weights[0] &lt;= capacity)
        {
            for(int c=weights[0] ; c &lt;= capacity; c++) {
                dp[0][c] = profits[0];
            }
        }


        // process all sub-arrays for all the capacities
        for(int i=1; i &lt; n; i++) {
            for(int c=1; c &lt;= capacity; c++) {
                int profit1= 0, profit2 = 0;
                // include the item, if it is not more than the capacity
                if(weights[i] &lt;= c)
                    profit1 = profits[i] + dp[i-1][c-weights[i]];
                // exclude the item
                profit2 = dp[i-1][c];
                // take maximum
                dp[i][c] = Math.max(profit1, profit2);
            }
        }

        // maximum profit will be at the bottom-right corner.
        return dp[n-1][capacity];
    }

    public static void main(String[] args) {
        KnapSack ks = new KnapSack();
        int[] profits = {1, 6, 10, 16};
        int[] weights = {1, 2, 3, 5};

        int maxProfit = ks.solveKnapsack(profits, weights, 7);
        System.out.println("Total knapsack profit ---&gt; " + maxProfit);

        maxProfit = ks.solveKnapsack(profits, weights, 6);
        System.out.println("Total knapsack profit ---&gt; " + maxProfit);
    }
}


Longest Palindromic Substring LC_005

Problem Description

Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:


  Input: “babad”
Output: “bab”
Note: “aba” is also a valid answer.


Example 2:


  Input: “cbbd”
Output: “bb”


Algorithm

code来自于GeeksforGeeks.

这一道的难点在于这个DP general case即使从一开始一个一个从base case开始写也想不出来.  不过其实这种问题很多Matrix DP都是存在的. 上一道其实还容易想一点, 因为是先把column0, row0 都set之后才开始做general case, 不用担心不存在的情况. 这道的话, 是从对角线开始set的, 如果从矩阵的层面去思考的话, 想半天可能都想不明白为什么能保证后面的dp一定被set.

换个思路, 这么想: 先set所有长度是1的, 然后是所有长度是2的. 后面从3开始, 自然会track以前1和2的, 然而1和2的都已经被set了. 4的话从3开始track, 而3都被set了.  这么想就容易很多.  这道的切入点是从每个subString的length, 这个思路很难想到.

最后想说这个不管怎么说还是没有递归的, 拿笔写几下会想的会更清楚. 干看的话看半天也不一定能看明白.

Solution

// Java Solution 
public class LongestPalinSubstring { 
	// A utility function to print 
	// a substring str[low..high] 
	static void printSubStr( 
		String str, int low, int high) 
	{ 
		System.out.println( 
			str.substring( 
				low, high + 1)); 
	} 

	// This function prints the longest 
	// palindrome substring of str[]. 
	// It also returns the length of the 
	// longest palindrome 
	static int longestPalSubstr(String str) 
	{ 
		// get length of input string 
		int n = str.length(); 

		// table[i][j] will be false if 
		// substring str[i..j] is not palindrome. 
		// Else table[i][j] will be true 
		boolean table[][] = new boolean[n][n]; 

		// All substrings of length 1 are palindromes 
		// 把对角线set, 每个dp[i][i] 里面只有一个元素肯定是true的
		int maxLength = 1; 
		for (int i = 0; i &lt; n; ++i) 
			table[i][i] = true; 

		// check for sub-string of length 2. 
		// 一个元素的set之后, 去set二元素的, 因为一个元素都解决了, 两个元素都是在一个元素基础之上的, 肯定是存在的. 
		int start = 0; 
		for (int i = 0; i &lt; n - 1; ++i) { 
			if (str.charAt(i) == str.charAt(i + 1)) { 
				table[i][i + 1] = true; 
				start = i; 
				maxLength = 2; 
			} 
		} 

		// Check for lengths greater than 2. 
		// k is length of substring  k是长度

		for (int k = 3; k &lt;= n; ++k) { 
			// Fix the starting index 
			// 这个算法比较特别, 是从每个string的长度去track的. 长度从小到大. 简而言之是check每个给定长度的所有可能的substring. 
			for (int i = 0; i &lt; n - k + 1; ++i) { 
				// Get the ending index of substring from 
				// starting index i and length k 
				int j = i + k - 1; 

				// checking for sub-string from ith index to 
				// jth index iff str.charAt(i+1) to 
				// str.charAt(j-1) is a palindrome 
				if (table[i + 1][j - 1] 
					&amp;&amp; str.charAt(i) == str.charAt(j)) { 
					table[i][j] = true; 

					if (k &gt; maxLength) { 
						start = i; 
						maxLength = k; 
					} 
				} 
			} 
		} 
		System.out.print("Longest palindrome substring is; "); 
		printSubStr(str, start, 
					start + maxLength - 1); 

		// return length of LPS 
		return maxLength; 
	} 

	// Driver program to test above functions 
	public static void main(String[] args) 
	{ 

		String str = "forgeeksskeegfor"; 
		System.out.println("Length is: " + longestPalSubstr(str)); 
	} 
} 

// This code is contributed by Sumit Ghosh 



Coin Machine
" />
    
    <meta name="author" content="Jericho" />

    
    <meta property="og:title" content="Dynamic Programming" />
    <meta property="twitter:title" content="Dynamic Programming" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

<!--adobe fonts-->
<script>
    (function(d) {
      var config = {
        kitId: 'vbt3gjx',
        scriptTimeout: 3000,
        async: true
      },
      h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script> 

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/ShadowArchive/style.css" />
  <link rel="alternate" type="application/rss+xml" title="Jericho - 「さて、どこへ行こうかしらね。ネットは広大だわ」" href="/ShadowArchive/feed.xml" />
  <link rel="shortcut icon" href="https://github.com/easonback26/ShadowArchive/blob/master/images/favicon.png?raw=true">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://unpkg.com/feather-icons"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?...">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->


  <!-- Here for the Light Gallery-->
  

  

</head>

  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/ShadowArchive/" class="site-avatar"><img src="https://github.com/easonback26/ShadowArchive/blob/master/images/Black_Trinity_Logo.png?raw=true" /></a>
       
      <h1 class="site-name"><a href="/ShadowArchive/">Jericho</a></h1>
      <p class="site-description">「さて、どこへ行こうかしらね。ネットは広大だわ」</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/ShadowArchive/">ホーム</a>
      
      
      
      <a href="/ShadowArchive/about">関連</a>
      
      
      
      <a href="/ShadowArchive/shortcuts">常備</a>
      
      
      
      <a href="/ShadowArchive/archive">归档</a>
      
      
      
      <a href="/ShadowArchive/photo">写真</a>
      
      
      
      <a href="/ShadowArchive/tags">付箋</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:contactshadowsong@gmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/easonback26" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright (c) 2020 Shadow Walker</p>

    </footer>
  </div>
</div>

    
      <aside class="toc">
        <ul>
  <li><a href="#">Dynamic Programming</a>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#fibonacci-类问题">Fibonacci 类问题</a>
        <ul>
          <li><a href="#fibonacci">Fibonacci</a></li>
          <li><a href="#climbing-stairs">Climbing Stairs</a></li>
        </ul>
      </li>
      <li><a href="#叠加后求maxmin问题">叠加后求Max/Min问题</a>
        <ul>
          <li><a href="#house-robber">House Robber</a></li>
        </ul>
      </li>
      <li><a href="#matrix-dp-问题">Matrix dp 问题</a>
        <ul>
          <li><a href="#non-fractional-knapsack">Non-Fractional Knapsack</a></li>
          <li><a href="#longest-palindromic-substring-lc_005">Longest Palindromic Substring LC_005</a></li>
          <li><a href="#coin-machine">Coin Machine</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
      </aside>
    

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        <article class="posts">
  <h1>Dynamic Programming</h1>

  <div clsss="meta">
    <span class="author">
      Shadow Walker
    </span>

    <span class="date">
      2020-08-16
    </span>

    <ul class="tag">
      
      <li>
        <a href="http://localhost:4000/ShadowArchive/tags#Algorithm">
          Algorithm
        </a>
      </li>
      
      <li>
        <a href="http://localhost:4000/ShadowArchive/tags#Interview">
          Interview
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <h2 id="overview">Overview</h2>

<p>DP相关的问题一直是我比较吃力和难以理解的一块. 希望通过总结知识点和相关题目能够增强对DP问题的理解.</p>

<p>窍门:</p>

<p><strong>如果写不出通式的话, 就从basic case一个一个写下去, 1,2,3,4, 多写几个就会有思路.</strong></p>

<h2 id="fibonacci-类问题">Fibonacci 类问题</h2>

<p>Fibonacci类的DP有一系列问题. 这种问题的特点有几点:</p>

<ol>
  <li>都是那种通过前后叠加去解决. 就是上楼梯问题.</li>
  <li>可以通过 Divide-Conquer 化解成 basic problem, 然后解决.</li>
  <li>表面上第一想到的通常用递归解决, 但用递归的话, 有指数复杂度.</li>
  <li>这一类我归结为单纯叠加, 不涉及Max和Min之类的问题, 相对来说比较简单.</li>
</ol>

<h3 id="fibonacci">Fibonacci</h3>

<p><strong>Description</strong></p>

<p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>

<blockquote>
  <p>F(0) = 0,   F(1) = 1<br />
F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</p>
</blockquote>

<p>Given N, calculate F(N).</p>

<p><strong>Solution</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="climbing-stairs">Climbing Stairs</h3>

<p><strong>Description</strong></p>

<p>You are climbing a stair case. It takes n steps to reach to the top.</p>

<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>

<p>Example 1:</p>

<blockquote>
  <p>Input: 2<br />
Output: 2<br />
Explanation: There are two ways to climb to the top.</p>
  <ol>
    <li>1 step + 1 step</li>
    <li>2 steps</li>
  </ol>
</blockquote>

<p>Example 2:</p>

<blockquote>
  <p>Input: 3<br />
Output: 3<br />
Explanation: There are three ways to climb to the top.</p>
  <ol>
    <li>1 step + 1 step + 1 step</li>
    <li>1 step + 2 steps</li>
    <li>2 steps + 1 step</li>
  </ol>
</blockquote>

<p><strong>Algorithm</strong></p>

<p>As we can see this problem can be broken into subproblems, and it contains the optimal substructure property i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic programming to solve this problem.</p>

<p>One can reach ith step in one of the two ways:</p>

<ol>
  <li>Taking a single step from <code class="language-plaintext highlighter-rouge">(i-1)th</code> step.</li>
  <li>Taking a step of 22 from <code class="language-plaintext highlighter-rouge">(i-2)th</code> step.</li>
</ol>

<p>So, the total number of ways to reach ith is equal to sum of ways of reaching <code class="language-plaintext highlighter-rouge">(i-1)th</code> step and ways of reaching <code class="language-plaintext highlighter-rouge">(i-2)th</code> step.</p>

<p>Let <code class="language-plaintext highlighter-rouge">dp[i]</code> denotes the number of ways to reach on ith step:</p>

<p><code class="language-plaintext highlighter-rouge">dp[i]=dp[i-1]+dp[i-2]</code></p>

<p><strong>Solution</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">climbStairs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="叠加后求maxmin问题">叠加后求Max/Min问题</h2>

<p>特点:</p>

<ol>
  <li>DP 有一个basic case, 从basic case扩展出一个general case</li>
  <li>这一类可以算是Fibonacci之上扩展出求Max/Min的问题</li>
  <li>DP从头递增/递减才能够计算. 不存在从中间或者什么奇怪的地方突然冒出来的DP</li>
  <li>DP基本都会涉及到Max 和 Min, 在Java之中用的是: <code class="language-plaintext highlighter-rouge">Math.max(a,b)</code></li>
  <li>基于第三点, DP的Max和Min存在叠加性, 即上一轮的Max可以保证这一轮的Max, 不存在诡异的地方影响. 这一点要牢记</li>
</ol>

<h3 id="house-robber">House Robber</h3>

<p><strong>Description</strong></p>

<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night.</strong></p>

<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police.</strong></p>

<p>Example 1:</p>

<blockquote>
  <p>Input: nums = [1,2,3,1]<br />
Output: 4<br />
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br />
             Total amount you can rob = 1 + 3 = 4.</p>
</blockquote>

<p>Example 2:</p>

<blockquote>
  <p>Input: nums = [2,7,9,3,1]<br />
Output: 12<br />
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br />
             Total amount you can rob = 2 + 9 + 1 = 12.</p>
</blockquote>

<p><strong>Algorithm</strong></p>

<p>This problem is equal to given an array, the solution is to find the maximum sum subsequence where no two selected elements are adjacent. So the approach to the problem is a recursive solution. So there are two cases.</p>

<p>Basic case:</p>
<ol>
  <li>no element, return 0;</li>
  <li>one element, return it.</li>
  <li>2 element, return max(first element, second element.</li>
</ol>

<p>General:
Two ways to reach max for ith element.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">nums[i] + dp[i-2]</code></li>
  <li><code class="language-plaintext highlighter-rouge">dp[i-1]</code></li>
</ol>

<p>比较这两种方法, 求二者之中的最大值, 即为<code class="language-plaintext highlighter-rouge">dp[i].</code></p>

<p><strong>Solution</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> 
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> 
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> 
            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> 
   
        <span class="c1">// dp[i] represent the maximum value stolen </span>
        <span class="c1">// so far after reaching house i. </span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> 
   
        <span class="c1">// Initialize the dp[0] and dp[1] </span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> 
   
        <span class="c1">// Fill remaining positions </span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> 
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span> 
   
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>分析</strong></p>

<p>这道题的话, 我自己做的话, 第一次是想不到标准答案那么完美的情况. 
如下图, 我会考虑从D点出发,为了避免相邻, 有四种情况, 我会从四种情况之中求max.</p>

<p><img src="../uploads/img/Screen Shot 2020-08-31 at 12.41.14 PM.png" alt="" /></p>

<p>如下, 是考虑了三中情况(图中1,3,4)而写出的答案.  但其实标准答案之中只考虑了三个量, 没有考虑A的存在, 因为A已经被其他dp包含了. <strong>但其实并不用过度担心这种多写</strong>. 因为Max这个方法是不会增加算力的. 即便多考虑几种情况放到max之中, 在LC之中依然是比100%的人跑得快.  所以这里也是DP的一个特点, <strong>DP看起来都很吓人, 但多动笔写写base case其实很容易出来</strong>.</p>

<p>另, <strong>这也就是Max问题和单纯Fibonacci的区别.</strong>  Fibonacci类需要考虑所有情况, 而Max类只需要考虑Max就可以.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> 
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> 
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> 
            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> 

   
        <span class="c1">// dp[i] represent the maximum value stolen </span>
        <span class="c1">// so far after reaching house i. </span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> 
   
        <span class="c1">// Initialize the dp[0] and dp[1] </span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> 
        <span class="n">dp</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
   
        <span class="c1">// Fill remaining positions </span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> 
            <span class="c1">//dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]);</span>
            <span class="c1">// 以上为标准答案的dp通式, 下面写的这个冗长, 考虑了三种, 但是不会增加算力. </span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]));</span>
   
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="matrix-dp-问题">Matrix dp 问题</h2>

<p>这个类型的dp, 我还没想好是否单独分一个类. 其主要的特点就是由一个matrix dp去解决, 出现了二维化, 而不仅仅是前面的一维.</p>

<p>这一块是比较难了. 即使能想明白, 也不一定能写对, 即使能写对也不一定能在规定的时间内写对.  对这一块目前来说还是学习和了解为主, 不需要完全掌握.</p>

<p>其实如果真理解的话, 其实这一套和一维的也不见得有很大区别.<strong>最大区别也就是多了一个capacity的给定量</strong>. 上边的题目没有限制, 只要去max就可以了, 而这个不同, 在一个有限的范围内给出max. 从而要不断去track这个给定量. 只要抓住这个关键点, 思路就清晰了很多.</p>

<h3 id="non-fractional-knapsack">Non-Fractional Knapsack</h3>

<p>关于这个问题, 这个<a href="https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/RM1BDv71V60#bottom-up-dynamic-programming">guide</a>写的最好了. 我下面的东西基本都是从这个guide里面来的, 改动很小.</p>

<p><strong>Problem Description</strong></p>

<p>Given the weights and profits of ‘N’ items, we are asked to put these items in a knapsack which has a capacity ‘C’. The goal is to get the maximum profit from the items in the knapsack. Each item can only be selected once, as we don’t have multiple quantities of any item.</p>

<p>Constraints:</p>

<ol>
  <li>an item cannot be used more than twice.</li>
  <li>In the list, there is only one item for each weights.</li>
  <li>If you take an item, you have to take it as a whole (non-fractional).</li>
</ol>

<p>Example:</p>

<p>Items: { Apple, Orange, Banana, Melon } <br />
Weights: { 2, 3, 1, 4 } <br />
Profits: { 4, 5, 3, 7 } <br />
Knapsack capacity: 5</p>

<p>We can have the following combinations:</p>

<p>Apple + Orange (total weight 5) =&gt; 9 profit <br />
Apple + Banana (total weight 3) =&gt; 7 profit <br />
Orange + Banana (total weight 4) =&gt; 8 profit <br />
Banana + Melon (total weight 5) =&gt; 10 profit</p>

<p><strong>Algorithm</strong></p>

<p>Essentially, we want to find the maximum profit for every sub-array and for every possible capacity. <strong>This means, <code class="language-plaintext highlighter-rouge">dp[i][c]</code> will represent the maximum knapsack profit for capacity <code class="language-plaintext highlighter-rouge">‘c’</code> calculated from the first <code class="language-plaintext highlighter-rouge">‘i’</code> items.</strong></p>

<p>So, for each item at index <code class="language-plaintext highlighter-rouge">‘i’ (0 &lt;= i &lt; items.length)</code> and capacity<code class="language-plaintext highlighter-rouge">‘c’ (0 &lt;= c &lt;= capacity) </code>, we have two options:</p>

<ol>
  <li>Exclude the item at index ‘i’. In this case, we will take whatever profit we get from the sub-array excluding this <code class="language-plaintext highlighter-rouge">item =&gt; dp[i-1][c]</code></li>
  <li>Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining <code class="language-plaintext highlighter-rouge">items =&gt; profits[i] + dp[i-1][c-weights[i]]</code></li>
</ol>

<p>其实从这里我们就可以看出, 二维和一维的情况是一样的, 无非两种情况, 选或者不选.  只不过多了一个capacity的量而已, 需要根据不同的capacity去track而已, 多了一个维度.</p>

<p>Finally, our optimal solution will be maximum of the above two values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dp[i][c] = max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]]) 
</code></pre></div></div>

<p>Given input of :        ` int[] profits = {1, 6, 10, 16};   int[] weights = {1, 2, 3, 5};`, we have a matrix dp of such:</p>

<p><img src="../uploads/img/Screen Shot 2020-09-02 at 8.51.32 PM.png" alt="" /></p>

<p><strong>Code</strong></p>

<ol>
  <li>这个code没有递归的, 我觉得是我看过的比较简洁易懂的, 只用一个方法. traverse一遍而已. 没有浪费memory</li>
  <li>这个方法是从前往后走, 即从前往后走.</li>
  <li>这个guide之中给的例子的两个list都是sorted, 我不确定unsorted的时候这个方法还能不能用. 应该是不行.</li>
  <li>basic case 分为三步,</li>
</ol>

  	- check edge case, 各种等于0. 
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- set column 0, 
- set row 0. 
</code></pre></div></div>

<ol>
  <li>general case 就像前面说过的, 无非两种情况, traverse 到 ith item的时候只有两种情况: 选或者不选, 然后取max.</li>
  <li>代码很吓人, 但像之前说的其实只有两种情况, 多看几分钟结合那个图看自然就看懂了. 可以去<a href="https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/RM1BDv71V60#bottom-up-dynamic-programming">guide</a>看一眼, 里面有动画.</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">KnapSack</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solveKnapsack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">profits</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">weights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.</span>

        <span class="c1">// basic checks</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">profits</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="n">profits</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">profits</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="c1">// populate the capacity=0 columns, with '0' capacity we have '0' profit</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	
	  <span class="c1">// Set row 0, i=0 means we are only allowed to take 0th item which is the first itme. </span>
        <span class="c1">// if we can only take the first item, we will take it if it is not more than the capacity</span>
        <span class="k">if</span><span class="o">(</span><span class="n">weights</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">weights</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">profits</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>


        <span class="c1">// process all sub-arrays for all the capacities</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">profit1</span><span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">profit2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">// include the item, if it is not more than the capacity</span>
                <span class="k">if</span><span class="o">(</span><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">)</span>
                    <span class="n">profit1</span> <span class="o">=</span> <span class="n">profits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">c</span><span class="o">-</span><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
                <span class="c1">// exclude the item</span>
                <span class="n">profit2</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>
                <span class="c1">// take maximum</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">profit1</span><span class="o">,</span> <span class="n">profit2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// maximum profit will be at the bottom-right corner.</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">capacity</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">KnapSack</span> <span class="n">ks</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KnapSack</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">profits</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">16</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">weights</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

        <span class="kt">int</span> <span class="n">maxProfit</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="na">solveKnapsack</span><span class="o">(</span><span class="n">profits</span><span class="o">,</span> <span class="n">weights</span><span class="o">,</span> <span class="mi">7</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total knapsack profit ---&gt; "</span> <span class="o">+</span> <span class="n">maxProfit</span><span class="o">);</span>

        <span class="n">maxProfit</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="na">solveKnapsack</span><span class="o">(</span><span class="n">profits</span><span class="o">,</span> <span class="n">weights</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total knapsack profit ---&gt; "</span> <span class="o">+</span> <span class="n">maxProfit</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="longest-palindromic-substring-lc_005">Longest Palindromic Substring LC_005</h3>

<p><strong>Problem Description</strong></p>

<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>

<p>Example 1:</p>

<blockquote>
  <p>Input: “babad”<br />
Output: “bab”<br />
Note: “aba” is also a valid answer.</p>
</blockquote>

<p>Example 2:</p>

<blockquote>
  <p>Input: “cbbd”<br />
Output: “bb”</p>
</blockquote>

<p><strong>Algorithm</strong></p>

<p>code来自于<a href="https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/">GeeksforGeeks</a>.</p>

<p>这一道的难点在于这个DP general case即使从一开始一个一个从base case开始写也想不出来.  不过其实这种问题很多Matrix DP都是存在的. 上一道其实还容易想一点, 因为是先把column0, row0 都set之后才开始做general case, 不用担心不存在的情况. 这道的话, 是从对角线开始set的, 如果从矩阵的层面去思考的话, 想半天可能都想不明白为什么能保证后面的dp一定被set.</p>

<p>换个思路, 这么想: <strong>先set所有长度是1的, 然后是所有长度是2的.</strong> 后面从3开始, 自然会track以前1和2的, 然而1和2的都已经被set了. 4的话从3开始track, 而3都被set了.  这么想就容易很多.  这道的切入点是从每个subString的length, 这个思路很难想到.</p>

<p>最后想说这个不管怎么说还是没有递归的, 拿笔写几下会想的会更清楚. 干看的话看半天也不一定能看明白.</p>

<p><strong>Solution</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Java Solution </span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LongestPalinSubstring</span> <span class="o">{</span> 
	<span class="c1">// A utility function to print </span>
	<span class="c1">// a substring str[low..high] </span>
	<span class="kd">static</span> <span class="kt">void</span> <span class="nf">printSubStr</span><span class="o">(</span> 
		<span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> 
	<span class="o">{</span> 
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> 
			<span class="n">str</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span> 
				<span class="n">low</span><span class="o">,</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span> 
	<span class="o">}</span> 

	<span class="c1">// This function prints the longest </span>
	<span class="c1">// palindrome substring of str[]. </span>
	<span class="c1">// It also returns the length of the </span>
	<span class="c1">// longest palindrome </span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="nf">longestPalSubstr</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> 
	<span class="o">{</span> 
		<span class="c1">// get length of input string </span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> 

		<span class="c1">// table[i][j] will be false if </span>
		<span class="c1">// substring str[i..j] is not palindrome. </span>
		<span class="c1">// Else table[i][j] will be true </span>
		<span class="kt">boolean</span> <span class="n">table</span><span class="o">[][]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span> 

		<span class="c1">// All substrings of length 1 are palindromes </span>
		<span class="c1">// 把对角线set, 每个dp[i][i] 里面只有一个元素肯定是true的</span>
		<span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> 
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> 
			<span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 

		<span class="c1">// check for sub-string of length 2. </span>
		<span class="c1">// 一个元素的set之后, 去set二元素的, 因为一个元素都解决了, 两个元素都是在一个元素基础之上的, 肯定是存在的. </span>
		<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span> 
			<span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span> 
				<span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 
				<span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> 
				<span class="n">maxLength</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> 
			<span class="o">}</span> 
		<span class="o">}</span> 

		<span class="c1">// Check for lengths greater than 2. </span>
		<span class="c1">// k is length of substring  k是长度</span>

		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span> 
			<span class="c1">// Fix the starting index </span>
			<span class="c1">// 这个算法比较特别, 是从每个string的长度去track的. 长度从小到大. 简而言之是check每个给定长度的所有可能的substring. </span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span> 
				<span class="c1">// Get the ending index of substring from </span>
				<span class="c1">// starting index i and length k </span>
				<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> 

				<span class="c1">// checking for sub-string from ith index to </span>
				<span class="c1">// jth index iff str.charAt(i+1) to </span>
				<span class="c1">// str.charAt(j-1) is a palindrome </span>
				<span class="k">if</span> <span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> 
					<span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span> 
					<span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 

					<span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">maxLength</span><span class="o">)</span> <span class="o">{</span> 
						<span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> 
						<span class="n">maxLength</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> 
					<span class="o">}</span> 
				<span class="o">}</span> 
			<span class="o">}</span> 
		<span class="o">}</span> 
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Longest palindrome substring is; "</span><span class="o">);</span> 
		<span class="n">printSubStr</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> 
					<span class="n">start</span> <span class="o">+</span> <span class="n">maxLength</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> 

		<span class="c1">// return length of LPS </span>
		<span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span> 
	<span class="o">}</span> 

	<span class="c1">// Driver program to test above functions </span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
	<span class="o">{</span> 

		<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"forgeeksskeegfor"</span><span class="o">;</span> 
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Length is: "</span> <span class="o">+</span> <span class="n">longestPalSubstr</span><span class="o">(</span><span class="n">str</span><span class="o">));</span> 
	<span class="o">}</span> 
<span class="o">}</span> 

<span class="c1">// This code is contributed by Sumit Ghosh </span>

</code></pre></div></div>

<h3 id="coin-machine">Coin Machine</h3>

  </div>


  <!-- 现在不用disqus评论了, 想用可以加上 评论区只有最上面comment true的时候才能用-->
  
<div class="comments">
    <div id="gitalk-container"></div>
    <script>
        const gitalk = new Gitalk({
          clientID: "ecd5f9ca822b01f65e22",
          clientSecret: "954fc161c6daece1d5d57bfc82d593a045d18551",
          repo: "ShadowArchive",
          owner: "easonback26",
          admin: ["easonback26"],
          id: window.location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false,  // Facebook-like distraction free mode
          title: "Dynamic Programming",
          language: "ja",

        })
        
        gitalk.render('gitalk-container')
    </script>
</div>

</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="http://localhost:4000/ShadowArchive/%E4%BA%BA%E6%97%8F%E5%BC%80%E5%B1%80%E5%BB%BA%E7%AD%91%E5%AD%A6/">
        ← 前に
      </a>
    </span>
  
  
    <span class="next" >
      <a href="http://localhost:4000/ShadowArchive/MusicIEnjoy/">
        次に →
      </a>
    </span>
  
</div>

<style>
.videoWrapper {
	position: relative;
	padding-bottom: 56.333%;
	height: 0;
    background: black;
}
.videoWrapper iframe {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
    border: 0;
}    
</style>

<script>
function get_youtube_id(url) {
    var p = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
    return (url.match(p)) ? RegExp.$1 : false;
}
function vimeo_embed(url,el) {
    var id = false;
    $.ajax({
      url: 'https://vimeo.com/api/oembed.json?url='+url,
      async: true,
      success: function(response) {
        if(response.video_id) {
          id = response.video_id;
          if(url.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0;
          if(url.indexOf('loop=1') !== -1) var loop=1; else var loop=0;
          var theInnerHTML = '<div class="videoWrapper"><iframe src="https://player.vimeo.com/video/'+id+'/?byline=0&title=0&portrait=0';
          if(autoplay==1) theInnerHTML += '&autoplay=1';
          if(loop==1) theInnerHTML += '&loop=1';
          theInnerHTML += '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>'; 
          el.innerHTML = theInnerHTML;
        }
      }
    });
}
function video_embed() {
    var p = document.getElementsByTagName('p');
    for(var i = 0; i < p.length; i++) {
        //check if this is an external url (that starts with https:// or http://
        if (p[i].innerHTML.indexOf("http://") == 0 ||
            p[i].innerHTML.indexOf("https://") == 0) {
            var youtube_id = get_youtube_id(p[i].innerHTML);
            if(youtube_id) {
                if(p[i].innerHTML.indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0;
                if(p[i].innerHTML.indexOf('loop=1') !== -1) var loop=1; else var loop=0;
                var theInnerHTML = '<div class="videoWrapper"><iframe width="720" height="420" src="https://www.youtube.com/embed/' + youtube_id + '?rel=0&showinfo=0';
                if(autoplay==1) theInnerHTML += '&autoplay=1';
                if(loop==1) theInnerHTML += '&loop=1&playlist='+youtube_id+'&version=3';
                if(p[i].innerHTML.indexOf('start=') !== -1) theInnerHTML += '&start='+p[i].innerHTML.substring(p[i].innerHTML.indexOf('start=')+6);
                theInnerHTML += '" frameborder="0" allowfullscreen></iframe></div>';
                p[i].innerHTML = theInnerHTML;
            }
            if(p[i].innerHTML.indexOf('vimeo.com') !== -1) {
                //ask vimeo for the id and place the embed
                vimeo_embed(p[i].innerHTML,p[i]);
            }
        }
    }
}
video_embed();

function mp3_embed() {
    var p = document.getElementsByTagName('p');
    for(var i = 0; i < p.length; i++) {
        if(p[i].innerHTML.indexOf('.mp3') !== -1) {
            var str = p[i].innerHTML.split('?');
            if(str.length == 1) str[1] = '';
            var str1 = str[1];
            str1 = str1.replace('&','').replace('&','');
            str1 = str1.replace('autoplay=1','').replace('autoplay=0','');
            str1 = str1.replace('loop=1','').replace('loop=0','');
            str1 = str1.replace('controls=0','').replace('controls=1','');

            if (str[0].lastIndexOf('.mp3', str[0].length - 4) === str[0].length - 4 && str1.length == 0) {
                if(str[1].indexOf('autoplay=1') !== -1) var autoplay=1; else var autoplay=0;
                if(str[1].indexOf('loop=1') !== -1) var loop=1; else var loop=0;
                if(str[1].indexOf('controls=0') !== -1) var controls=0; else var controls=1;
                var newInnerHTML = '<audio';
                if(autoplay==1) newInnerHTML += ' autoplay';
                if(loop==1) newInnerHTML += ' loop';
                if(controls==1) newInnerHTML += ' controls';
                newInnerHTML += '><source src="'+str[0]+'" type="audio/mpeg">Your browser does not support the audio element.</audio>';
                p[i].innerHTML = newInnerHTML;
            }
        }
    }
}
mp3_embed();
</script>





      </div>
    </div>

    



  </body>

  
  <script>
    document.getElementById("main").classList.add("withtoc");
  </script>
  

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  
  <li><a href="mailto:contactshadowsong@gmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/easonback26" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright (c) 2020 Shadow Walker</p>

    </footer>


</html>
